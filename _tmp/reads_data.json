[
  {
    "transcriptLine": 84,
    "offset": 1410,
    "limit": 120,
    "firstLine": 1410,
    "lastLine": 1529,
    "rawContent": "  1410→    let graveScaleX = 1.0, graveScaleY = 1.0;\n  1411→    const graveTopEl2 = graveTopEl || document.getElementById(`${ownerKey}-grave-top`);\n  1412→    if (graveTopEl2) {\n  1413→        const tRect = graveTopEl2.getBoundingClientRect();\n  1414→        graveX = tRect.left + tRect.width / 2 - cardWidth / 2;\n  1415→        graveY = tRect.top + tRect.height / 2 - cardHeight / 2;\n  1416→        graveScaleX = tRect.width / cardWidth;\n  1417→        graveScaleY = tRect.height / cardHeight;\n  1418→    } else if (graveEl) {\n  1419→        const gRect = graveEl.getBoundingClientRect();\n  1420→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  1421→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  1422→        graveScaleX = gRect.width / cardWidth;\n  1423→        graveScaleY = gRect.height / cardHeight;\n  1424→    }\n  1425→\n  1426→    // Position de reveal : à côté du deck (pas au centre)\n  1427→    const revealX = startX;\n  1428→    const revealY = startY - cardHeight - 20;\n  1429→\n  1430→    // Wrapper avec perspective\n  1431→    const wrapper = document.createElement('div');\n  1432→    wrapper.style.cssText = `\n  1433→        position: fixed; z-index: 10000; pointer-events: none;\n  1434→        left: ${startX}px; top: ${startY}px;\n  1435→        width: ${cardWidth}px; height: ${cardHeight}px;\n  1436→        transform-origin: center center;\n  1437→        transform: scale(1); opacity: 0;\n  1438→        perspective: 800px;\n  1439→    `;\n  1440→\n  1441→    // Flipper 3D\n  1442→    const flipper = document.createElement('div');\n  1443→    flipper.style.cssText = `\n  1444→        width: 100%; height: 100%;\n  1445→        position: relative;\n  1446→        transform-style: preserve-3d;\n  1447→        transform: rotateY(0deg);\n  1448→    `;\n  1449→\n  1450→    // Dos de carte\n  1451→    const backFace = document.createElement('div');\n  1452→    backFace.className = 'opp-card-back';\n  1453→    backFace.style.cssText = `\n  1454→        position: absolute; top: 0; left: 0;\n  1455→        width: 100%; height: 100%;\n  1456→        backface-visibility: hidden;\n  1457→        transform: rotateY(0deg);\n  1458→        border-radius: 6px;\n  1459→    `;\n  1460→\n  1461→    // Face avant (template board = false, comme les cartes sur le terrain)\n  1462→    const frontFace = (typeof makeCard === 'function')\n  1463→        ? makeCard(card, false)\n  1464→        : createCardElementForAnimation(card);\n  1465→    frontFace.classList.remove('just-played', 'can-attack');\n  1466→    frontFace.classList.add('in-graveyard');\n  1467→    const bgImage = frontFace.style.backgroundImage;\n  1468→    frontFace.style.position = 'absolute';\n  1469→    frontFace.style.top = '0';\n  1470→    frontFace.style.left = '0';\n  1471→    frontFace.style.width = '100%';\n  1472→    frontFace.style.height = '100%';\n  1473→    frontFace.style.margin = '0';\n  1474→    frontFace.style.backfaceVisibility = 'hidden';\n  1475→    frontFace.style.transform = 'rotateY(180deg)';\n  1476→    if (bgImage) frontFace.style.backgroundImage = bgImage;\n  1477→\n  1478→    flipper.appendChild(backFace);\n  1479→    flipper.appendChild(frontFace);\n  1480→    wrapper.appendChild(flipper);\n  1481→\n  1482→    // Conteneur perspective pour matcher l'inclinaison du game-board\n  1483→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  1484→    let perspContainer = null;\n  1485→    let graveTiltDeg = 0;\n  1486→    if (gameBoardWrapper) {\n  1487→        const gameBoard = document.querySelector('.game-board');\n  1488→        if (gameBoard) {\n  1489→            const computedTransform = getComputedStyle(gameBoard).transform;\n  1490→            if (computedTransform && computedTransform !== 'none') {\n  1491→                const mat = new DOMMatrix(computedTransform);\n  1492→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  1493→            }\n  1494→        }\n  1495→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  1496→        perspContainer = document.createElement('div');\n  1497→        perspContainer.dataset.animBorn = Date.now();\n  1498→        perspContainer.style.cssText = `\n  1499→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  1500→            z-index: 10000; pointer-events: none;\n  1501→            perspective: 1500px;\n  1502→            perspective-origin: ${gbwRect.left + gbwRect.width / 2}px ${gbwRect.top + gbwRect.height / 2}px;\n  1503→        `;\n  1504→        document.body.appendChild(perspContainer);\n  1505→        perspContainer.appendChild(wrapper);\n  1506→    } else {\n  1507→        document.body.appendChild(wrapper);\n  1508→    }\n  1509→\n  1510→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  1511→    if (graveTopEl2) {\n  1512→        const savedLeft = wrapper.style.left;\n  1513→        const savedTop = wrapper.style.top;\n  1514→        const savedTransform = wrapper.style.transform;\n  1515→        const target = graveTopEl2.getBoundingClientRect();\n  1516→        for (let pass = 0; pass < 3; pass++) {\n  1517→            wrapper.style.left = graveX + 'px';\n  1518→            wrapper.style.top = graveY + 'px';\n  1519→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  1520→            const m = wrapper.getBoundingClientRect();\n  1521→            if (m.width > 0 && m.height > 0) {\n  1522→                graveScaleX *= target.width / m.width;\n  1523→                graveScaleY *= target.height / m.height;\n  1524→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  1525→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  1526→            }\n  1527→\n  1528→        }\n  1529→        wrapper.style.left = savedLeft;"
  },
  {
    "transcriptLine": 86,
    "offset": 1700,
    "limit": 120,
    "firstLine": 1700,
    "lastLine": 1819,
    "rawContent": "  1700→    const cardHeight = 189;\n  1701→    // Centrer la carte fixe sur le centre visuel du slot\n  1702→    const startX = slotRect.left + slotRect.width / 2 - cardWidth / 2;\n  1703→    const startY = slotRect.top + slotRect.height / 2 - cardHeight / 2;\n  1704→\n  1705→    // 3. Position cible : cimetière du propriétaire — utiliser grave-top pour dimensions EXACTES\n  1706→    const graveEl = document.getElementById(owner === 'me' ? 'me-grave-box' : 'opp-grave-box');\n  1707→    const deathGraveTop = document.getElementById(`${ownerKey}-grave-top`);\n  1708→    let graveX = startX;\n  1709→    let graveY = startY + 200;\n  1710→    let graveScaleX = 1.0, graveScaleY = 1.0;\n  1711→    if (deathGraveTop) {\n  1712→        const tRect = deathGraveTop.getBoundingClientRect();\n  1713→        graveX = tRect.left + tRect.width / 2 - cardWidth / 2;\n  1714→        graveY = tRect.top + tRect.height / 2 - cardHeight / 2;\n  1715→        graveScaleX = tRect.width / cardWidth;\n  1716→        graveScaleY = tRect.height / cardHeight;\n  1717→    } else if (graveEl) {\n  1718→        const gRect = graveEl.getBoundingClientRect();\n  1719→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  1720→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  1721→        graveScaleX = gRect.width / cardWidth;\n  1722→        graveScaleY = gRect.height / cardHeight;\n  1723→    }\n  1724→\n  1725→    // 4. Créer le wrapper avec la carte\n  1726→    const wrapper = document.createElement('div');\n  1727→    wrapper.style.cssText = `\n  1728→        position: fixed; z-index: 10000; pointer-events: none;\n  1729→        left: ${startX}px; top: ${startY}px;\n  1730→        width: ${cardWidth}px; height: ${cardHeight}px;\n  1731→        transform-origin: center center;\n  1732→        transform: scale(1); opacity: 1;\n  1733→    `;\n  1734→\n  1735→    // Créer la face de la carte\n  1736→    let cardFace;\n  1737→    if (data.card && typeof makeCard === 'function') {\n  1738→        cardFace = makeCard(data.card, false);\n  1739→    } else if (cardEl) {\n  1740→        cardFace = cardEl.cloneNode(true);\n  1741→    } else {\n  1742→        graveRenderBlocked.delete(ownerKey);\n  1743→        animatingSlots.delete(deathSlotKey);\n  1744→        return;\n  1745→    }\n  1746→    const bgImage = cardFace.style.backgroundImage;\n  1747→    cardFace.style.position = 'absolute';\n  1748→    cardFace.style.top = '0';\n  1749→    cardFace.style.left = '0';\n  1750→    cardFace.style.width = cardWidth + 'px';\n  1751→    cardFace.style.height = cardHeight + 'px';\n  1752→    cardFace.style.margin = '0';\n  1753→    if (bgImage) cardFace.style.backgroundImage = bgImage;\n  1754→    // Forcer les tailles board sur les stats (la carte n'est plus dans .card-slot → CSS réduit les stats)\n  1755→    cardFace.querySelectorAll('.arena-atk, .arena-hp, .arena-armor').forEach(el => {\n  1756→        el.style.width = '30px';\n  1757→        el.style.height = '30px';\n  1758→        el.style.fontSize = '20px';\n  1759→        el.style.borderWidth = '2px';\n  1760→    });\n  1761→    wrapper.appendChild(cardFace);\n  1762→\n  1763→    // 5. Retirer la carte originale du slot immédiatement\n  1764→    if (cardEl) {\n  1765→        cardEl.remove();\n  1766→    }\n  1767→    slot.classList.remove('has-card');\n  1768→    slot.classList.remove('has-flying');\n  1769→\n  1770→    // Débloquer le slot — la carte est maintenant dans le wrapper volant, render() peut toucher le slot\n  1771→    animatingSlots.delete(deathSlotKey);\n  1772→\n  1773→    // 6. Perspective container (même technique que animateBurn)\n  1774→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  1775→    let perspContainer = null;\n  1776→    let graveTiltDeg = 0;\n  1777→    if (gameBoardWrapper) {\n  1778→        const gameBoard = document.querySelector('.game-board');\n  1779→        if (gameBoard) {\n  1780→            const computedTransform = getComputedStyle(gameBoard).transform;\n  1781→            if (computedTransform && computedTransform !== 'none') {\n  1782→                const mat = new DOMMatrix(computedTransform);\n  1783→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  1784→            }\n  1785→        }\n  1786→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  1787→        perspContainer = document.createElement('div');\n  1788→        perspContainer.dataset.animBorn = Date.now();\n  1789→        perspContainer.style.cssText = `\n  1790→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  1791→            z-index: 10000; pointer-events: none;\n  1792→            perspective: 1500px;\n  1793→            perspective-origin: ${gbwRect.left + gbwRect.width / 2}px ${gbwRect.top + gbwRect.height / 2}px;\n  1794→        `;\n  1795→        document.body.appendChild(perspContainer);\n  1796→        perspContainer.appendChild(wrapper);\n  1797→    } else {\n  1798→        document.body.appendChild(wrapper);\n  1799→    }\n  1800→\n  1801→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  1802→    if (deathGraveTop) {\n  1803→        const savedLeft = wrapper.style.left;\n  1804→        const savedTop = wrapper.style.top;\n  1805→        const savedTransform = wrapper.style.transform;\n  1806→        const target = deathGraveTop.getBoundingClientRect();\n  1807→        for (let pass = 0; pass < 3; pass++) {\n  1808→            wrapper.style.left = graveX + 'px';\n  1809→            wrapper.style.top = graveY + 'px';\n  1810→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  1811→            const m = wrapper.getBoundingClientRect();\n  1812→            if (m.width > 0 && m.height > 0) {\n  1813→                graveScaleX *= target.width / m.width;\n  1814→                graveScaleY *= target.height / m.height;\n  1815→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  1816→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  1817→            }\n  1818→\n  1819→        }"
  },
  {
    "transcriptLine": 88,
    "offset": 2340,
    "limit": 100,
    "firstLine": 2340,
    "lastLine": 2439,
    "rawContent": "  2340→        graveScaleY = tRect.height / cardHeight;\n  2341→    } else if (graveEl) {\n  2342→        const gRect = graveEl.getBoundingClientRect();\n  2343→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  2344→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  2345→        graveScaleX = gRect.width / cardWidth;\n  2346→        graveScaleY = gRect.height / cardHeight;\n  2347→    }\n  2348→\n  2349→    // 4. Position de départ : depuis la main (startRect) ou materialisation classique\n  2350→    const hasStartRect = !!startRect;\n  2351→    // Sort adverse sans startRect : flip 3D (dos → face) à la position showcase\n  2352→    const isOppFlip = !isMine && !hasStartRect;\n  2353→    // Mes sorts : le wrapper démarre à showcaseScale (net), un clone léger fait le vol depuis la main\n  2354→    const isMyFly = isMine && hasStartRect;\n  2355→\n  2356→    // Le wrapper démarre TOUJOURS à la position/scale showcase (rasterisation nette)\n  2357→    const wrapper = document.createElement('div');\n  2358→    wrapper.style.cssText = `\n  2359→        position: fixed; z-index: 10000; pointer-events: none;\n  2360→        left: ${showcaseX}px; top: ${showcaseY}px;\n  2361→        width: ${cardWidth}px; height: ${cardHeight}px;\n  2362→        transform-origin: center center;\n  2363→        transform: scale(${showcaseScale}); opacity: ${(isOppFlip || isMyFly) ? 1 : 0};\n  2364→        perspective: 800px;\n  2365→    `;\n  2366→    // Mes sorts : wrapper caché pendant le vol, révélé à l'arrivée\n  2367→    if (isMyFly) {\n  2368→        wrapper.style.opacity = '0';\n  2369→    }\n  2370→\n  2371→    // Sort adverse : structure flipper (dos + face) pour le flip 3D\n  2372→    let flipper = null;\n  2373→    if (isOppFlip) {\n  2374→        flipper = document.createElement('div');\n  2375→        flipper.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;transform-style:preserve-3d;';\n  2376→\n  2377→        // Dos de carte\n  2378→        const backFace = document.createElement('div');\n  2379→        backFace.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;backface-visibility:hidden;border-radius:6px;overflow:hidden;';\n  2380→        const backImg = document.createElement('img');\n  2381→        backImg.src = 'cardback/back_1.png';\n  2382→        backImg.style.cssText = 'width:100%;height:100%;display:block;';\n  2383→        backFace.appendChild(backImg);\n  2384→\n  2385→        // Face du sort (commence retournée, invisible)\n  2386→        cardEl.style.backfaceVisibility = 'hidden';\n  2387→        cardEl.style.transform = 'rotateY(180deg)';\n  2388→\n  2389→        flipper.appendChild(backFace);\n  2390→        flipper.appendChild(cardEl);\n  2391→        wrapper.appendChild(flipper);\n  2392→    } else {\n  2393→        wrapper.appendChild(cardEl);\n  2394→    }\n  2395→\n  2396→    // Mes sorts : clone léger qui vole de la main vers le showcase (même taille de base, scale pour grandir)\n  2397→    let flyClone = null;\n  2398→    let flyStartScale = 1;\n  2399→    if (isMyFly) {\n  2400→        // Taille de base = cardWidth × cardHeight, scale pour matcher la taille de la main\n  2401→        flyStartScale = startRect.width / cardWidth;\n  2402→        const startCX = startRect.left + startRect.width / 2;\n  2403→        const startCY = startRect.top + startRect.height / 2;\n  2404→        flyClone = document.createElement('div');\n  2405→        flyClone.style.cssText = `\n  2406→            position: fixed; z-index: 10001; pointer-events: none;\n  2407→            left: ${startCX - cardWidth / 2}px; top: ${startCY - cardHeight / 2}px;\n  2408→            width: ${cardWidth}px; height: ${cardHeight}px;\n  2409→            border-radius: 6px; overflow: hidden;\n  2410→            transform-origin: center center;\n  2411→            transform: scale(${flyStartScale});\n  2412→        `;\n  2413→        const flyCardEl = makeCard(card, true);\n  2414→        flyCardEl.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;margin:0;';\n  2415→        if (card.image) flyCardEl.style.backgroundImage = `url('/cards/${card.image}')`;\n  2416→        flyClone.appendChild(flyCardEl);\n  2417→        document.body.appendChild(flyClone);\n  2418→    }\n  2419→\n  2420→    // 5. Perspective container pour le fly-to-graveyard (même technique que animateBurn)\n  2421→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  2422→    let perspContainer = null;\n  2423→    let graveTiltDeg = 0;\n  2424→    if (gameBoardWrapper) {\n  2425→        const gb = document.querySelector('.game-board');\n  2426→        if (gb) {\n  2427→            const computedTransform = getComputedStyle(gb).transform;\n  2428→            if (computedTransform && computedTransform !== 'none') {\n  2429→                const mat = new DOMMatrix(computedTransform);\n  2430→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  2431→            }\n  2432→        }\n  2433→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  2434→        perspContainer = document.createElement('div');\n  2435→        perspContainer.dataset.animBorn = Date.now();\n  2436→        perspContainer.style.cssText = `\n  2437→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  2438→            z-index: 10000; pointer-events: none;\n  2439→            perspective: 1500px;"
  },
  {
    "transcriptLine": 114,
    "offset": 3160,
    "limit": 80,
    "firstLine": 3160,
    "lastLine": 3239,
    "rawContent": "  3160→    const owner = data.player === myNum ? 'me' : 'opp';\n  3161→    const slotKey = `${owner}-${data.row}-${data.col}`;\n  3162→    animatingSlots.add(slotKey);\n  3163→\n  3164→    const slot = getSlot(owner, data.row, data.col);\n  3165→    if (!slot) {\n  3166→        animatingSlots.delete(slotKey);\n  3167→        return;\n  3168→    }\n  3169→\n  3170→    const cardInSlot = slot.querySelector('.card');\n  3171→    const slotRect = slot.getBoundingClientRect();\n  3172→\n  3173→    // Dimensions de la carte sur le board\n  3174→    const cardWidth = 140;\n  3175→    const cardHeight = 189;\n  3176→    const startX = slotRect.left + slotRect.width / 2 - cardWidth / 2;\n  3177→    const startY = slotRect.top + slotRect.height / 2 - cardHeight / 2;\n  3178→\n  3179→    // Cacher la vraie carte dans le slot\n  3180→    if (cardInSlot) cardInSlot.style.visibility = 'hidden';\n  3181→\n  3182→    // Créer le wrapper animé\n  3183→    const wrapper = document.createElement('div');\n  3184→    wrapper.style.cssText = `\n  3185→        position: fixed;\n  3186→        z-index: 10000;\n  3187→        pointer-events: none;\n  3188→        left: ${startX}px;\n  3189→        top: ${startY}px;\n  3190→        width: ${cardWidth}px;\n  3191→        height: ${cardHeight}px;\n  3192→        transform-origin: center center;\n  3193→    `;\n  3194→\n  3195→    // Carte face visible — préserver le backgroundImage\n  3196→    const cardFace = makeCard(data.card, false);\n  3197→    const bgImage = cardFace.style.backgroundImage;\n  3198→    cardFace.style.position = 'absolute';\n  3199→    cardFace.style.top = '0';\n  3200→    cardFace.style.left = '0';\n  3201→    cardFace.style.width = '100%';\n  3202→    cardFace.style.height = '100%';\n  3203→    cardFace.style.margin = '0';\n  3204→    cardFace.style.boxShadow = '0 0 20px rgba(100, 180, 255, 0.6)';\n  3205→    if (bgImage) cardFace.style.backgroundImage = bgImage;\n  3206→\n  3207→    wrapper.appendChild(cardFace);\n  3208→    document.body.appendChild(wrapper);\n  3209→\n  3210→    // Auto-fit du nom (les noms longs débordent pendant l'animation)\n  3211→    const bounceNameFit = cardFace.querySelector('.arena-name');\n  3212→    if (bounceNameFit) fitArenaName(bounceNameFit);\n  3213→\n  3214→    // === PHASE 1 : LIFT (200ms) — carte se soulève du slot ===\n  3215→    const liftHeight = 40;\n  3216→    const liftScale = 1.08;\n  3217→\n  3218→    await new Promise(resolve => {\n  3219→        const dur = 200;\n  3220→        const t0 = performance.now();\n  3221→        function animate() {\n  3222→            const p = Math.min((performance.now() - t0) / dur, 1);\n  3223→            const ep = easeOutCubic(p);\n  3224→            wrapper.style.top = (startY - ep * liftHeight) + 'px';\n  3225→            wrapper.style.transform = `scale(${1 + ep * (liftScale - 1)})`;\n  3226→            const glow = ep * 25;\n  3227→            cardFace.style.boxShadow = `0 0 ${glow}px rgba(100, 180, 255, ${ep * 0.8}), 0 4px 12px rgba(0,0,0,0.4)`;\n  3228→            if (p < 1) requestAnimationFrame(animate); else resolve();\n  3229→        }\n  3230→        requestAnimationFrame(animate);\n  3231→    });\n  3232→\n  3233→    // Convertir de scale vers coordonnées visuelles réelles (pas de changement visuel)\n  3234→    const liftEndCssY = startY - liftHeight;\n  3235→    const floatX = startX + cardWidth * (1 - liftScale) / 2;\n  3236→    const floatY = liftEndCssY + cardHeight * (1 - liftScale) / 2;\n  3237→    const floatW = cardWidth * liftScale;\n  3238→    const floatH = cardHeight * liftScale;\n  3239→"
  },
  {
    "transcriptLine": 116,
    "offset": 3500,
    "limit": 100,
    "firstLine": 3500,
    "lastLine": 3599,
    "rawContent": "  3500→    // Retirer la carte de la popup cimetière si ouverte\n  3501→    removeCardFromGraveyardPopup(owner, data.card);\n  3502→\n  3503→    // Source : le cimetière du propriétaire\n  3504→    const graveTopEl = document.getElementById(`${owner}-grave-top`);\n  3505→    const graveBox = document.getElementById(`${owner}-grave-box`);\n  3506→    const sourceEl = graveTopEl || graveBox;\n  3507→    if (!sourceEl) {\n  3508→        return;\n  3509→    }\n  3510→\n  3511→    const sourceRect = sourceEl.getBoundingClientRect();\n  3512→\n  3513→    // Dimensions de la carte (même taille que bounce)\n  3514→    const cardWidth = 140;\n  3515→    const cardHeight = 189;\n  3516→    const startX = sourceRect.left + sourceRect.width / 2 - cardWidth / 2;\n  3517→    const startY = sourceRect.top + sourceRect.height / 2 - cardHeight / 2;\n  3518→\n  3519→    // Créer le wrapper animé (identique à bounce)\n  3520→    const wrapper = document.createElement('div');\n  3521→    wrapper.style.cssText = `\n  3522→        position: fixed;\n  3523→        z-index: 10000;\n  3524→        pointer-events: none;\n  3525→        left: ${startX}px;\n  3526→        top: ${startY}px;\n  3527→        width: ${cardWidth}px;\n  3528→        height: ${cardHeight}px;\n  3529→        transform-origin: center center;\n  3530→    `;\n  3531→\n  3532→    // Carte face visible — préserver le backgroundImage (identique à bounce)\n  3533→    const cardFace = makeCard(data.card, false);\n  3534→    const bgImage = cardFace.style.backgroundImage;\n  3535→    cardFace.style.position = 'absolute';\n  3536→    cardFace.style.top = '0';\n  3537→    cardFace.style.left = '0';\n  3538→    cardFace.style.width = '100%';\n  3539→    cardFace.style.height = '100%';\n  3540→    cardFace.style.margin = '0';\n  3541→    cardFace.style.boxShadow = '0 0 20px rgba(100, 180, 255, 0.6)';\n  3542→    if (bgImage) cardFace.style.backgroundImage = bgImage;\n  3543→\n  3544→    wrapper.appendChild(cardFace);\n  3545→    document.body.appendChild(wrapper);\n  3546→\n  3547→    // Auto-fit du nom (identique à bounce)\n  3548→    const bounceNameFit = cardFace.querySelector('.arena-name');\n  3549→    if (bounceNameFit) fitArenaName(bounceNameFit);\n  3550→\n  3551→    // Utiliser le pendingBounce pré-enregistré au queue time, ou en créer un nouveau\n  3552→    let targetPromise;\n  3553→    if (data._bounceTargetPromise) {\n  3554→        targetPromise = data._bounceTargetPromise;\n  3555→        if (pendingBounce) pendingBounce.wrapper = wrapper;\n  3556→    } else {\n  3557→        targetPromise = new Promise(resolve => {\n  3558→            pendingBounce = { owner, card: data.card, wrapper, resolveTarget: resolve };\n  3559→        });\n  3560→    }\n  3561→\n  3562→    // === PHASE 1 : LIFT (200ms) — carte se soulève du cimetière (identique à bounce) ===\n  3563→    const liftHeight = 40;\n  3564→    const liftScale = 1.08;\n  3565→\n  3566→    await new Promise(resolve => {\n  3567→        const dur = 200;\n  3568→        const t0 = performance.now();\n  3569→        function animate() {\n  3570→            const p = Math.min((performance.now() - t0) / dur, 1);\n  3571→            const ep = easeOutCubic(p);\n  3572→            wrapper.style.top = (startY - ep * liftHeight) + 'px';\n  3573→            wrapper.style.transform = `scale(${1 + ep * (liftScale - 1)})`;\n  3574→            const glow = ep * 25;\n  3575→            cardFace.style.boxShadow = `0 0 ${glow}px rgba(100, 180, 255, ${ep * 0.8}), 0 4px 12px rgba(0,0,0,0.4)`;\n  3576→            if (p < 1) requestAnimationFrame(animate); else resolve();\n  3577→        }\n  3578→        requestAnimationFrame(animate);\n  3579→    });\n  3580→\n  3581→    // Convertir de scale vers coordonnées visuelles réelles (identique à bounce)\n  3582→    const liftEndCssY = startY - liftHeight;\n  3583→    const floatX = startX + cardWidth * (1 - liftScale) / 2;\n  3584→    const floatY = liftEndCssY + cardHeight * (1 - liftScale) / 2;\n  3585→    const floatW = cardWidth * liftScale;\n  3586→    const floatH = cardHeight * liftScale;\n  3587→\n  3588→    wrapper.style.left = floatX + 'px';\n  3589→    wrapper.style.top = floatY + 'px';\n  3590→    wrapper.style.width = floatW + 'px';\n  3591→    wrapper.style.height = floatH + 'px';\n  3592→    wrapper.style.transform = 'none';\n  3593→\n  3594→    // Après le lift, si le state est déjà arrivé et que le target n'est pas encore résolu,\n  3595→    // forcer la résolution depuis le DOM actuel (évite l'attente en l'air)\n  3596→    if (pendingBounce && pendingBounce.owner === owner && !pendingBounce.resolved) {\n  3597→        const existingCards = owner === 'me'\n  3598→            ? document.querySelectorAll('#my-hand .card:not(.committed-spell)')\n  3599→            : document.querySelectorAll('#opp-hand .opp-card-back');"
  },
  {
    "transcriptLine": 118,
    "offset": 4030,
    "limit": 80,
    "firstLine": 4030,
    "lastLine": 4109,
    "rawContent": "  4030→            // Carte cachée → flip classique dos → face\n  4031→            const wrapper = document.createElement('div');\n  4032→            wrapper.style.cssText = `\n  4033→                position: fixed; z-index: 2000; pointer-events: none;\n  4034→                left: ${rect.left}px; top: ${rect.top}px;\n  4035→                width: ${cw}px; height: ${ch}px;\n  4036→                perspective: 800px;\n  4037→            `;\n  4038→\n  4039→            const flipInner = document.createElement('div');\n  4040→            flipInner.style.cssText = `\n  4041→                width: 100%; height: 100%;\n  4042→                position: relative; transform-style: preserve-3d;\n  4043→            `;\n  4044→\n  4045→            const backFace = document.createElement('div');\n  4046→            backFace.style.cssText = `\n  4047→                position: absolute; top: 0; left: 0;\n  4048→                width: 100%; height: 100%; margin: 0;\n  4049→                border-radius: 6px; overflow: hidden;\n  4050→                box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n  4051→                backface-visibility: hidden;\n  4052→            `;\n  4053→            const backImg = document.createElement('img');\n  4054→            backImg.src = 'cardback/back_1.png';\n  4055→            backImg.style.cssText = 'width: 100%; height: 100%; display: block;';\n  4056→            backFace.appendChild(backImg);\n  4057→\n  4058→            const cardEl = makeCard(data.card, false);\n  4059→            const bgImage = cardEl.style.backgroundImage;\n  4060→            cardEl.style.position = 'absolute';\n  4061→            cardEl.style.top = '0';\n  4062→            cardEl.style.left = '0';\n  4063→            cardEl.style.width = '100%';\n  4064→            cardEl.style.height = '100%';\n  4065→            cardEl.style.margin = '0';\n  4066→            cardEl.style.backfaceVisibility = 'hidden';\n  4067→            cardEl.style.transform = 'rotateY(180deg)';\n  4068→            if (bgImage) cardEl.style.backgroundImage = bgImage;\n  4069→\n  4070→            flipInner.appendChild(backFace);\n  4071→            flipInner.appendChild(cardEl);\n  4072→            wrapper.appendChild(flipInner);\n  4073→            document.body.appendChild(wrapper);\n  4074→\n  4075→            const liftDur = 180;\n  4076→            const flipDur = 380;\n  4077→            const settleDur = 180;\n  4078→            const liftPx = 25;\n  4079→            const startY = rect.top;\n  4080→            const t0 = performance.now();\n  4081→\n  4082→            function easeInOutQuad(t) { return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; }\n  4083→            function easeInCubic(t) { return t * t * t; }\n  4084→\n  4085→            function animate() {\n  4086→                const elapsed = performance.now() - t0;\n  4087→                if (elapsed < liftDur) {\n  4088→                    const p = easeOutCubic(elapsed / liftDur);\n  4089→                    wrapper.style.top = (startY - liftPx * p) + 'px';\n  4090→                } else if (elapsed < liftDur + flipDur) {\n  4091→                    wrapper.style.top = (startY - liftPx) + 'px';\n  4092→                    const p = easeInOutQuad((elapsed - liftDur) / flipDur);\n  4093→                    flipInner.style.transform = `rotateY(${180 * p}deg)`;\n  4094→                } else if (elapsed < liftDur + flipDur + settleDur) {\n  4095→                    flipInner.style.transform = 'rotateY(180deg)';\n  4096→                    const p = easeInCubic((elapsed - liftDur - flipDur) / settleDur);\n  4097→                    wrapper.style.top = (startY - liftPx + liftPx * p) + 'px';\n  4098→                } else {\n  4099→                    wrapper.remove();\n  4100→                    animatingSlots.delete(slotKey);\n  4101→                    render();\n  4102→                    return;\n  4103→                }\n  4104→                requestAnimationFrame(animate);\n  4105→            }\n  4106→            requestAnimationFrame(animate);\n  4107→        }\n  4108→    });\n  4109→}"
  },
  {
    "transcriptLine": 121,
    "offset": 3990,
    "limit": 50,
    "firstLine": 3990,
    "lastLine": 4039,
    "rawContent": "  3990→            const bgImage = cardEl.style.backgroundImage;\n  3991→            cardEl.style.position = 'absolute';\n  3992→            cardEl.style.top = '0';\n  3993→            cardEl.style.left = '0';\n  3994→            cardEl.style.width = '100%';\n  3995→            cardEl.style.height = '100%';\n  3996→            cardEl.style.margin = '0';\n  3997→            if (bgImage) cardEl.style.backgroundImage = bgImage;\n  3998→\n  3999→            wrapper.appendChild(cardEl);\n  4000→            document.body.appendChild(wrapper);\n  4001→\n  4002→            const liftDur = 180;\n  4003→            const settleDur = 180;\n  4004→            const liftPx = 25;\n  4005→            const startY = rect.top;\n  4006→            const t0 = performance.now();\n  4007→            function easeInCubic(t) { return t * t * t; }\n  4008→\n  4009→            function animate() {\n  4010→                const elapsed = performance.now() - t0;\n  4011→                if (elapsed < liftDur) {\n  4012→                    const p = easeOutCubic(elapsed / liftDur);\n  4013→                    wrapper.style.top = (startY - liftPx * p) + 'px';\n  4014→                } else if (elapsed < liftDur + settleDur) {\n  4015→                    const p = easeInCubic((elapsed - liftDur) / settleDur);\n  4016→                    wrapper.style.top = (startY - liftPx + liftPx * p) + 'px';\n  4017→                } else {\n  4018→                    wrapper.remove();\n  4019→                    animatingSlots.delete(slotKey);\n  4020→                    // Nettoyer le cache maintenant que l'animation est finie\n  4021→                    if (data.card && data.card.uid) savedRevealedCardRects.delete(data.card.uid);\n  4022→                    render();\n  4023→                    return;\n  4024→                }\n  4025→                requestAnimationFrame(animate);\n  4026→            }\n  4027→            requestAnimationFrame(animate);\n  4028→\n  4029→        } else {\n  4030→            // Carte cachée → flip classique dos → face\n  4031→            const wrapper = document.createElement('div');\n  4032→            wrapper.style.cssText = `\n  4033→                position: fixed; z-index: 2000; pointer-events: none;\n  4034→                left: ${rect.left}px; top: ${rect.top}px;\n  4035→                width: ${cw}px; height: ${ch}px;\n  4036→                perspective: 800px;\n  4037→            `;\n  4038→\n  4039→            const flipInner = document.createElement('div');"
  },
  {
    "transcriptLine": 123,
    "offset": 2680,
    "limit": 30,
    "firstLine": 2680,
    "lastLine": 2709,
    "rawContent": "  2680→            }\n  2681→        }\n  2682→\n  2683→        requestAnimationFrame(animate);\n  2684→    });\n  2685→}\n  2686→\n  2687→async function animateSpell(data) {\n  2688→    // Fly from opponent hand before revealing the spell\n  2689→    if (data.spell && data.caster !== myNum) {\n  2690→        const gameBoard = document.querySelector('.game-board');\n  2691→        if (gameBoard) {\n  2692→            const gbRect = gameBoard.getBoundingClientRect();\n  2693→            const cardW = 140, cardH = 189, sc = 1.8;\n  2694→            const showcaseX = gbRect.left + gbRect.width * 0.80 - (cardW * sc) / 2;\n  2695→            const showcaseY = gbRect.top + gbRect.height * 0.45 - (cardH * sc) / 2;\n  2696→            // Utiliser la position sauvegardée de la carte dans la main adverse (avant le rebuild)\n  2697→            const savedRect = (data.visualHandIndex >= 0 && savedOppHandRects)\n  2698→                ? savedOppHandRects[data.visualHandIndex] : null;\n  2699→            await flyFromOppHand({ left: showcaseX, top: showcaseY, width: cardW * sc, height: cardH * sc }, 300, data.spell, savedRect);\n  2700→        }\n  2701→    }\n  2702→    // Pour nos propres sorts : récupérer la position du sort engagé dans la main\n  2703→    let startRect = null;\n  2704→    if (data.spell && data.caster === myNum && committedSpells.length > 0) {\n  2705→        const handPanel = document.getElementById('my-hand');\n  2706→        const committedEls = handPanel ? handPanel.querySelectorAll('.committed-spell') : [];\n  2707→        const csIdx = committedSpells.findIndex(cs => cs.card.id === data.spell.id);\n  2708→        if (csIdx >= 0) {\n  2709→            const commitId = committedSpells[csIdx].commitId;"
  },
  {
    "transcriptLine": 125,
    "offset": 4190,
    "limit": 80,
    "firstLine": 4190,
    "lastLine": 4269,
    "rawContent": "  4190→// Animation d'invocation par piège — apparition magique directement dans le slot (hérite de la perspective 3D)\n  4191→// Synchronisée avec createTrapSummonEffect (PixiJS VFX) :\n  4192→//   Phase 0: 0-400ms      Energy gathering (VFX only, card invisible)\n  4193→//   Phase 1: 400-800ms    Portal opens (VFX only, card invisible)\n  4194→//   Phase 2: 800-1000ms   Flash & card materializes (card scale 0→1, brightness 3→1)\n  4195→//   Phase 3: 1000-1500ms  Card settles with easeOutBack (card stable, glow fades)\n  4196→//   Phase 4: 1500-2800ms  Idle shimmer (card done, VFX trails off)\n  4197→function animateTrapSummon(data) {\n  4198→    const owner = data.player === myNum ? 'me' : 'opp';\n  4199→    const slotKey = `${owner}-${data.row}-${data.col}`;\n  4200→    animatingSlots.add(slotKey);\n  4201→\n  4202→    const slot = getSlot(owner, data.row, data.col);\n  4203→    if (!slot) { animatingSlots.delete(slotKey); return; }\n  4204→\n  4205→    // Vider le slot\n  4206→    const label = slot.querySelector('.slot-label');\n  4207→    slot.innerHTML = '';\n  4208→    if (label) slot.appendChild(label.cloneNode(true));\n  4209→    slot.classList.remove('has-card');\n  4210→\n  4211→    const rect = slot.getBoundingClientRect();\n  4212→\n  4213→    // VFX PixiJS (portail rotatif, particules convergentes, energy lines, flash, shimmer)\n  4214→    const v = _vfxRect(rect);\n  4215→    CombatVFX.createTrapSummonEffect(v.x, v.y, v.w, v.h);\n  4216→\n  4217→    // Créer la carte directement DANS le slot (hérite de la perspective du board : rotateX 18deg)\n  4218→    const cardEl = makeCard(data.card, false);\n  4219→    cardEl.style.transformOrigin = 'center center';\n  4220→    cardEl.style.transform = 'scale(0)';\n  4221→    cardEl.style.opacity = '0';\n  4222→    cardEl.style.filter = 'brightness(3) saturate(0)';\n  4223→    cardEl.style.pointerEvents = 'none';\n  4224→    slot.appendChild(cardEl);\n  4225→    slot.classList.add('has-card');\n  4226→\n  4227→    // Auto-fit du nom\n  4228→    const summonNameFit = cardEl.querySelector('.arena-name');\n  4229→    if (summonNameFit) fitArenaName(summonNameFit);\n  4230→\n  4231→    // Glow magique derrière la carte (dans le slot — violet/doré)\n  4232→    const glow = document.createElement('div');\n  4233→    glow.style.cssText = `\n  4234→        position: absolute; inset: -20px; z-index: -1; border-radius: 12px;\n  4235→        background: radial-gradient(ellipse at center, rgba(122,90,240,0.8) 0%, rgba(180,140,255,0.4) 40%, transparent 70%);\n  4236→        opacity: 0; pointer-events: none; transform: scale(0.3);\n  4237→    `;\n  4238→    slot.appendChild(glow);\n  4239→\n  4240→    const totalDur = 1500; // La carte est prête à 1500ms, le VFX PixiJS continue en arrière-plan\n  4241→    const t0 = performance.now();\n  4242→\n  4243→    function animate() {\n  4244→        const elapsed = performance.now() - t0;\n  4245→        const tMs = Math.min(elapsed, totalDur);\n  4246→\n  4247→        // Phase 0-1: 0-800ms — VFX only, glow monte doucement, carte invisible\n  4248→        if (tMs < 800) {\n  4249→            const p = tMs / 800;\n  4250→            glow.style.opacity = `${easeOutCubic(p) * 0.7}`;\n  4251→            glow.style.transform = `scale(${0.3 + 0.9 * easeOutCubic(p)})`;\n  4252→            cardEl.style.transform = 'scale(0)';\n  4253→            cardEl.style.opacity = '0';\n  4254→        }\n  4255→\n  4256→        // Phase 2: 800-1000ms — Flash & card materializes\n  4257→        else if (tMs < 1000) {\n  4258→            const p = (tMs - 800) / 200;\n  4259→            const ep = easeOutCubic(p);\n  4260→\n  4261→            // Carte émerge d'un halo lumineux\n  4262→            cardEl.style.transform = `scale(${easeOutBack(p)})`;\n  4263→            cardEl.style.opacity = `${Math.min(ep * 3, 1)}`;\n  4264→            const brightness = 3 - 2 * ep;\n  4265→            const saturate = ep;\n  4266→            cardEl.style.filter = `brightness(${brightness}) saturate(${saturate})`;\n  4267→\n  4268→            // Glow intense\n  4269→            glow.style.opacity = `${0.7 + 0.3 * (1 - p)}`;"
  },
  {
    "transcriptLine": 128,
    "offset": 3940,
    "limit": 60,
    "firstLine": 3940,
    "lastLine": 3999,
    "rawContent": "  3940→\n  3941→    // Le slot devrait déjà être bloqué par blockSlots, mais on s'assure\n  3942→    animatingSlots.add(slotKey);\n  3943→\n  3944→    // Trouver le slot cible\n  3945→    const slot = getSlot(owner, data.row, data.col);\n  3946→    if (!slot) { animatingSlots.delete(slotKey); return; }\n  3947→\n  3948→    // Vider le slot (au cas où)\n  3949→    const label = slot.querySelector('.slot-label');\n  3950→    slot.innerHTML = '';\n  3951→    if (label) slot.appendChild(label.cloneNode(true));\n  3952→    slot.classList.remove('has-card');\n  3953→\n  3954→    const rect = slot.getBoundingClientRect();\n  3955→    const cw = rect.width, ch = rect.height;\n  3956→\n  3957→    const isRevealed = data.card && data.card.revealedToOpponent;\n  3958→\n  3959→    // Utiliser la position sauvegardée au début de la révélation (avant re-render)\n  3960→    let savedSourceRect = null;\n  3961→    if (isRevealed && data.card.uid) {\n  3962→        savedSourceRect = savedRevealedCardRects.get(data.card.uid) || null;\n  3963→        // NE PAS supprimer du cache ici — la carte reste cachée dans le DOM\n  3964→        // tant que l'animation n'est pas terminée (state updates peuvent re-render)\n  3965→    }\n  3966→\n  3967→    // Pour les créatures non révélées : utiliser visualHandIndex pour voler depuis la bonne position\n  3968→    if (!savedSourceRect && data.visualHandIndex >= 0) {\n  3969→        const handPanel = document.getElementById('opp-hand');\n  3970→        const handCards = handPanel ? handPanel.querySelectorAll('.opp-card-back') : [];\n  3971→        if (data.visualHandIndex < handCards.length) {\n  3972→            savedSourceRect = handCards[data.visualHandIndex].getBoundingClientRect();\n  3973→        }\n  3974→    }\n  3975→\n  3976→    // Phase 1 : carte vole de la main adverse vers le slot (300ms)\n  3977→    // Si révélée, la carte vole face visible depuis sa position sauvegardée\n  3978→    flyFromOppHand(rect, 300, isRevealed ? data.card : null, savedSourceRect).then(() => {\n  3979→\n  3980→        if (isRevealed) {\n  3981→            // Carte déjà révélée → pas de flip, juste lever + poser face visible\n  3982→            const wrapper = document.createElement('div');\n  3983→            wrapper.style.cssText = `\n  3984→                position: fixed; z-index: 2000; pointer-events: none;\n  3985→                left: ${rect.left}px; top: ${rect.top}px;\n  3986→                width: ${cw}px; height: ${ch}px;\n  3987→            `;\n  3988→\n  3989→            const cardEl = makeCard(data.card, false);\n  3990→            const bgImage = cardEl.style.backgroundImage;\n  3991→            cardEl.style.position = 'absolute';\n  3992→            cardEl.style.top = '0';\n  3993→            cardEl.style.left = '0';\n  3994→            cardEl.style.width = '100%';\n  3995→            cardEl.style.height = '100%';\n  3996→            cardEl.style.margin = '0';\n  3997→            if (bgImage) cardEl.style.backgroundImage = bgImage;\n  3998→\n  3999→            wrapper.appendChild(cardEl);"
  },
  {
    "transcriptLine": 130,
    "offset": 4410,
    "limit": 60,
    "firstLine": 4410,
    "lastLine": 4464,
    "rawContent": "  4410→\n  4411→    // Bloquer les deux slots (origine et destination)\n  4412→    animatingSlots.add(fromKey);\n  4413→    animatingSlots.add(toKey);\n  4414→\n  4415→    // Vider les DEUX slots immédiatement (pour éviter le doublon visuel)\n  4416→    const labelFrom = fromSlot.querySelector('.slot-label');\n  4417→    fromSlot.innerHTML = '';\n  4418→    if (labelFrom) fromSlot.appendChild(labelFrom.cloneNode(true));\n  4419→    fromSlot.classList.remove('has-card');\n  4420→\n  4421→    const labelTo = toSlot.querySelector('.slot-label');\n  4422→    toSlot.innerHTML = '';\n  4423→    if (labelTo) toSlot.appendChild(labelTo.cloneNode(true));\n  4424→    toSlot.classList.remove('has-card');\n  4425→\n  4426→    // Récupérer les positions\n  4427→    const fromRect = fromSlot.getBoundingClientRect();\n  4428→    const toRect = toSlot.getBoundingClientRect();\n  4429→    const dx = toRect.left - fromRect.left;\n  4430→    const dy = toRect.top - fromRect.top;\n  4431→\n  4432→    // Créer une carte overlay (makeCard met le backgroundImage en inline, on ne doit pas l'écraser)\n  4433→    const movingCard = makeCard(data.card, false);\n  4434→    movingCard.style.position = 'fixed';\n  4435→    movingCard.style.left = fromRect.left + 'px';\n  4436→    movingCard.style.top = fromRect.top + 'px';\n  4437→    movingCard.style.width = fromRect.width + 'px';\n  4438→    movingCard.style.height = fromRect.height + 'px';\n  4439→    movingCard.style.zIndex = '3000';\n  4440→    movingCard.style.pointerEvents = 'none';\n  4441→    movingCard.style.transform = 'translate3d(0px, 0px, 0px)';\n  4442→    movingCard.style.transition = 'transform 0.5s ease-in-out';\n  4443→\n  4444→    document.body.appendChild(movingCard);\n  4445→\n  4446→    // Forcer le reflow puis déclencher la transition via transform\n  4447→    movingCard.getBoundingClientRect();\n  4448→    requestAnimationFrame(() => {\n  4449→        movingCard.style.transform = `translate3d(${dx}px, ${dy}px, 0px)`;\n  4450→    });\n  4451→\n  4452→    // Nettoyer après l'animation (500ms transition + 100ms marge)\n  4453→    setTimeout(() => {\n  4454→        // Débloquer et render AVANT de supprimer l'overlay\n  4455→        // pour éviter un flash sans jeton buff\n  4456→        animatingSlots.delete(fromKey);\n  4457→        animatingSlots.delete(toKey);\n  4458→        render();\n  4459→        movingCard.remove();\n  4460→    }, 600);\n  4461→}\n  4462→\n  4463→\n  4464→"
  },
  {
    "transcriptLine": 190,
    "offset": 1378,
    "limit": 120,
    "firstLine": 1378,
    "lastLine": 1497,
    "rawContent": "  1378→async function animateBurn(data) {\n  1379→    const owner = data.player === myNum ? 'me' : 'opp';\n  1380→    const ownerKey = owner === 'me' ? 'me' : 'opp';\n  1381→    const card = data.card;\n  1382→\n  1383→    // graveRenderBlocked déjà incrémenté par queueAnimation — pas de double add\n  1384→\n  1385→    const deckEl = document.getElementById(owner === 'me' ? 'me-deck-stack' : 'opp-deck-stack');\n  1386→    if (!deckEl) {\n  1387→        graveRenderBlocked.delete(ownerKey);\n  1388→        return;\n  1389→    }\n  1390→\n  1391→    const graveEl = document.getElementById(owner === 'me' ? 'me-grave-box' : 'opp-grave-box');\n  1392→\n  1393→    const deckRect = deckEl.getBoundingClientRect();\n  1394→    const cardWidth = 140;\n  1395→    const cardHeight = 189;\n  1396→\n  1397→    const startX = deckRect.left + deckRect.width / 2 - cardWidth / 2;\n  1398→    const startY = deckRect.top;\n  1399→\n  1400→    // Cacher le cimetière temporairement (la carte n'y est pas encore visuellement)\n  1401→    const graveTopEl = document.getElementById(`${owner}-grave-top`);\n  1402→    let graveSnapshot = null;\n  1403→    if (graveTopEl) {\n  1404→        graveSnapshot = graveTopEl.innerHTML;\n  1405→    }\n  1406→\n  1407→    // Position et taille visuelle du cimetière — utiliser grave-top pour les dimensions EXACTES\n  1408→    let graveX = startX;\n  1409→    let graveY = startY + 200;\n  1410→    let graveScaleX = 1.0, graveScaleY = 1.0;\n  1411→    const graveTopEl2 = graveTopEl || document.getElementById(`${ownerKey}-grave-top`);\n  1412→    if (graveTopEl2) {\n  1413→        const tRect = graveTopEl2.getBoundingClientRect();\n  1414→        graveX = tRect.left + tRect.width / 2 - cardWidth / 2;\n  1415→        graveY = tRect.top + tRect.height / 2 - cardHeight / 2;\n  1416→        graveScaleX = tRect.width / cardWidth;\n  1417→        graveScaleY = tRect.height / cardHeight;\n  1418→    } else if (graveEl) {\n  1419→        const gRect = graveEl.getBoundingClientRect();\n  1420→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  1421→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  1422→        graveScaleX = gRect.width / cardWidth;\n  1423→        graveScaleY = gRect.height / cardHeight;\n  1424→    }\n  1425→\n  1426→    // Position de reveal : à côté du deck (pas au centre)\n  1427→    const revealX = startX;\n  1428→    const revealY = startY - cardHeight - 20;\n  1429→\n  1430→    // Wrapper avec perspective\n  1431→    const wrapper = document.createElement('div');\n  1432→    wrapper.style.cssText = `\n  1433→        position: fixed; z-index: 10000; pointer-events: none;\n  1434→        left: ${startX}px; top: ${startY}px;\n  1435→        width: ${cardWidth}px; height: ${cardHeight}px;\n  1436→        transform-origin: center center;\n  1437→        transform: scale(1); opacity: 0;\n  1438→        perspective: 800px;\n  1439→    `;\n  1440→\n  1441→    // Flipper 3D\n  1442→    const flipper = document.createElement('div');\n  1443→    flipper.style.cssText = `\n  1444→        width: 100%; height: 100%;\n  1445→        position: relative;\n  1446→        transform-style: preserve-3d;\n  1447→        transform: rotateY(0deg);\n  1448→    `;\n  1449→\n  1450→    // Dos de carte\n  1451→    const backFace = document.createElement('div');\n  1452→    backFace.className = 'opp-card-back';\n  1453→    backFace.style.cssText = `\n  1454→        position: absolute; top: 0; left: 0;\n  1455→        width: 100%; height: 100%;\n  1456→        backface-visibility: hidden;\n  1457→        transform: rotateY(0deg);\n  1458→        border-radius: 6px;\n  1459→    `;\n  1460→\n  1461→    // Face avant (template board = false, comme les cartes sur le terrain)\n  1462→    const frontFace = (typeof makeCard === 'function')\n  1463→        ? makeCard(card, false)\n  1464→        : createCardElementForAnimation(card);\n  1465→    frontFace.classList.remove('just-played', 'can-attack');\n  1466→    frontFace.classList.add('in-graveyard');\n  1467→    const bgImage = frontFace.style.backgroundImage;\n  1468→    frontFace.style.position = 'absolute';\n  1469→    frontFace.style.top = '0';\n  1470→    frontFace.style.left = '0';\n  1471→    frontFace.style.width = '100%';\n  1472→    frontFace.style.height = '100%';\n  1473→    frontFace.style.margin = '0';\n  1474→    frontFace.style.backfaceVisibility = 'hidden';\n  1475→    frontFace.style.transform = 'rotateY(180deg)';\n  1476→    if (bgImage) frontFace.style.backgroundImage = bgImage;\n  1477→\n  1478→    flipper.appendChild(backFace);\n  1479→    flipper.appendChild(frontFace);\n  1480→    wrapper.appendChild(flipper);\n  1481→\n  1482→    // Conteneur perspective pour matcher l'inclinaison du game-board\n  1483→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  1484→    let perspContainer = null;\n  1485→    let graveTiltDeg = 0;\n  1486→    if (gameBoardWrapper) {\n  1487→        const gameBoard = document.querySelector('.game-board');\n  1488→        if (gameBoard) {\n  1489→            const computedTransform = getComputedStyle(gameBoard).transform;\n  1490→            if (computedTransform && computedTransform !== 'none') {\n  1491→                const mat = new DOMMatrix(computedTransform);\n  1492→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  1493→            }\n  1494→        }\n  1495→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  1496→        perspContainer = document.createElement('div');\n  1497→        perspContainer.dataset.animBorn = Date.now();"
  },
  {
    "transcriptLine": 192,
    "offset": 1497,
    "limit": 180,
    "firstLine": 1497,
    "lastLine": 1676,
    "rawContent": "  1497→        perspContainer.dataset.animBorn = Date.now();\n  1498→        perspContainer.style.cssText = `\n  1499→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  1500→            z-index: 10000; pointer-events: none;\n  1501→            perspective: 1500px;\n  1502→            perspective-origin: ${gbwRect.left + gbwRect.width / 2}px ${gbwRect.top + gbwRect.height / 2}px;\n  1503→        `;\n  1504→        document.body.appendChild(perspContainer);\n  1505→        perspContainer.appendChild(wrapper);\n  1506→    } else {\n  1507→        document.body.appendChild(wrapper);\n  1508→    }\n  1509→\n  1510→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  1511→    if (graveTopEl2) {\n  1512→        const savedLeft = wrapper.style.left;\n  1513→        const savedTop = wrapper.style.top;\n  1514→        const savedTransform = wrapper.style.transform;\n  1515→        const target = graveTopEl2.getBoundingClientRect();\n  1516→        for (let pass = 0; pass < 3; pass++) {\n  1517→            wrapper.style.left = graveX + 'px';\n  1518→            wrapper.style.top = graveY + 'px';\n  1519→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  1520→            const m = wrapper.getBoundingClientRect();\n  1521→            if (m.width > 0 && m.height > 0) {\n  1522→                graveScaleX *= target.width / m.width;\n  1523→                graveScaleY *= target.height / m.height;\n  1524→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  1525→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  1526→            }\n  1527→\n  1528→        }\n  1529→        wrapper.style.left = savedLeft;\n  1530→        wrapper.style.top = savedTop;\n  1531→        wrapper.style.transform = savedTransform;\n  1532→    }\n  1533→\n  1534→    // Auto-fit du nom (les noms longs débordent pendant l'animation)\n  1535→    const burnNameFit = frontFace.querySelector('.arena-name');\n  1536→    if (burnNameFit) fitArenaName(burnNameFit);\n  1537→\n  1538→    // Durées (réduites pour enchaîner rapidement quand plusieurs burns)\n  1539→    const liftDuration = 120;\n  1540→    const flipDuration = 250;\n  1541→    const holdDuration = 250;\n  1542→    const flyDuration = 300;\n  1543→    const totalDuration = liftDuration + flipDuration + holdDuration + flyDuration;\n  1544→\n  1545→    await new Promise(resolve => {\n  1546→        const startTime = performance.now();\n  1547→\n  1548→        const safetyTimeout = setTimeout(() => {\n  1549→            graveRenderBlocked.delete(ownerKey);\n  1550→            wrapper.remove();\n  1551→            if (perspContainer) perspContainer.remove();\n  1552→            resolve();\n  1553→        }, totalDuration + 500);\n  1554→\n  1555→        function animate() {\n  1556→            const elapsed = performance.now() - startTime;\n  1557→            const progress = Math.min(elapsed / totalDuration, 1);\n  1558→\n  1559→            const t1 = liftDuration / totalDuration;\n  1560→            const t2 = (liftDuration + flipDuration) / totalDuration;\n  1561→            const t3 = (liftDuration + flipDuration + holdDuration) / totalDuration;\n  1562→\n  1563→            let x, y, scaleX, scaleY, opacity, flipDeg, redTint, tiltDeg;\n  1564→\n  1565→            if (progress <= t1) {\n  1566→                // === PHASE 1: LIFT ===\n  1567→                const p = progress / t1;\n  1568→                const ep = easeOutCubic(p);\n  1569→                x = startX;\n  1570→                y = startY - ep * 30;\n  1571→                scaleX = scaleY = 1 + ep * 0.05;\n  1572→                opacity = 0.3 + ep * 0.7;\n  1573→                flipDeg = 0;\n  1574→                redTint = 0;\n  1575→                tiltDeg = 0;\n  1576→\n  1577→            } else if (progress <= t2) {\n  1578→                // === PHASE 2: FLIP (retourne la carte près du deck) ===\n  1579→                const p = (progress - t1) / (t2 - t1);\n  1580→                const ep = easeInOutCubic(p);\n  1581→                x = startX + (revealX - startX) * ep;\n  1582→                y = (startY - 30) + (revealY - (startY - 30)) * ep;\n  1583→                scaleX = scaleY = 1.05 + (1.2 - 1.05) * ep;\n  1584→                opacity = 1;\n  1585→                flipDeg = easeInOutCubic(p) * 180;\n  1586→                redTint = 0;\n  1587→                tiltDeg = 0;\n  1588→\n  1589→            } else if (progress <= t3) {\n  1590→                // === PHASE 3: HOLD (teinte rouge progressive) ===\n  1591→                const p = (progress - t2) / (t3 - t2);\n  1592→                x = revealX;\n  1593→                y = revealY;\n  1594→                scaleX = scaleY = 1.2;\n  1595→                opacity = 1;\n  1596→                flipDeg = 180;\n  1597→                redTint = easeOutCubic(p) * 0.6;\n  1598→                tiltDeg = 0;\n  1599→\n  1600→            } else {\n  1601→                // === PHASE 4: FLY TO GRAVEYARD ===\n  1602→                const p = (progress - t3) / (1 - t3);\n  1603→                const ep = easeInOutCubic(p);\n  1604→                x = revealX + (graveX - revealX) * ep;\n  1605→                y = revealY + (graveY - revealY) * ep;\n  1606→                scaleX = 1.2 + (graveScaleX - 1.2) * ep;\n  1607→                scaleY = 1.2 + (graveScaleY - 1.2) * ep;\n  1608→                opacity = 1;\n  1609→                flipDeg = 180;\n  1610→                redTint = 0.6;\n  1611→                tiltDeg = ep * graveTiltDeg;\n  1612→            }\n  1613→\n  1614→            wrapper.style.left = x + 'px';\n  1615→            wrapper.style.top = y + 'px';\n  1616→            wrapper.style.opacity = opacity;\n  1617→            wrapper.style.transform = `scale(${scaleX}, ${scaleY}) rotateX(${tiltDeg}deg)`;\n  1618→            flipper.style.transform = `rotateY(${flipDeg}deg)`;\n  1619→\n  1620→            // Teinte rouge via overlay\n  1621→            if (redTint > 0) {\n  1622→                wrapper.style.filter = `sepia(${redTint * 0.5}) saturate(${1 + redTint * 2}) hue-rotate(-10deg) brightness(${1 - redTint * 0.2})`;\n  1623→            } else {\n  1624→                wrapper.style.filter = 'none';\n  1625→            }\n  1626→\n  1627→            if (progress < 1) {\n  1628→                requestAnimationFrame(animate);\n  1629→            } else {\n  1630→                clearTimeout(safetyTimeout);\n  1631→\n  1632→                // Cacher le wrapper AVANT de placer la carte (même frame synchrone = pas de pop)\n  1633→                wrapper.style.visibility = 'hidden';\n  1634→\n  1635→                // Débloquer et mettre à jour le cimetière\n  1636→                // Afficher la carte de CE burn comme top card (pas la dernière du state,\n  1637→                // car le state peut déjà contenir les burns suivants)\n  1638→                graveRenderBlocked.delete(ownerKey);\n  1639→                const topContainer = document.getElementById(`${ownerKey}-grave-top`);\n  1640→                if (topContainer) {\n  1641→                    const burnCardId = card.uid || card.id;\n  1642→                    topContainer.dataset.topCardUid = burnCardId;\n  1643→                    topContainer.classList.remove('empty');\n  1644→                    topContainer.innerHTML = '';\n  1645→                    const burnCardEl = makeCard(card, false);\n  1646→                    burnCardEl.classList.remove('just-played', 'can-attack');\n  1647→                    burnCardEl.classList.add('grave-card', 'in-graveyard');\n  1648→                    topContainer.appendChild(burnCardEl);\n  1649→                    const burnNameEl = burnCardEl.querySelector('.arena-name');\n  1650→                    if (burnNameEl) fitArenaName(burnNameEl);\n  1651→                }\n  1652→                if (state) {\n  1653→                    const graveyard = owner === 'me' ? state.me?.graveyard : state.opponent?.graveyard;\n  1654→                    if (graveyard) {\n  1655→                        updateGraveDisplay(ownerKey, graveyard);\n  1656→                    }\n  1657→                }\n  1658→\n  1659→                // Mise à jour dynamique de la popup cimetière\n  1660→                addCardToGraveyardPopup(ownerKey, card);\n  1661→\n  1662→                wrapper.remove();\n  1663→                if (perspContainer) perspContainer.remove();\n  1664→                resolve();\n  1665→            }\n  1666→        }\n  1667→\n  1668→        requestAnimationFrame(animate);\n  1669→    });\n  1670→}\n  1671→\n  1672→/**\n  1673→ * Animation de mort — la carte vole vers le cimetière (style Hearthstone/Arena)\n  1674→ * Phase 1 - Death Mark (400ms) : greyscale progressif + léger shrink\n  1675→ * Phase 2 - Fly to Graveyard (500ms) : vol vers le cimetière avec perspective tilt\n  1676→ */"
  },
  {
    "transcriptLine": 203,
    "offset": 1508,
    "limit": 30,
    "firstLine": 1508,
    "lastLine": 1537,
    "rawContent": "  1508→        document.body.appendChild(perspContainer);\n  1509→        perspContainer.appendChild(wrapper);\n  1510→    } else {\n  1511→        document.body.appendChild(wrapper);\n  1512→    }\n  1513→\n  1514→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  1515→    if (graveTopEl2) {\n  1516→        const savedLeft = wrapper.style.left;\n  1517→        const savedTop = wrapper.style.top;\n  1518→        const savedTransform = wrapper.style.transform;\n  1519→        const target = graveTopEl2.getBoundingClientRect();\n  1520→        for (let pass = 0; pass < 3; pass++) {\n  1521→            wrapper.style.left = graveX + 'px';\n  1522→            wrapper.style.top = graveY + 'px';\n  1523→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  1524→            const m = wrapper.getBoundingClientRect();\n  1525→            if (m.width > 0 && m.height > 0) {\n  1526→                graveScaleX *= target.width / m.width;\n  1527→                graveScaleY *= target.height / m.height;\n  1528→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  1529→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  1530→            }\n  1531→\n  1532→        }\n  1533→        wrapper.style.left = savedLeft;\n  1534→        wrapper.style.top = savedTop;\n  1535→        wrapper.style.transform = savedTransform;\n  1536→    }\n  1537→"
  },
  {
    "transcriptLine": 213,
    "offset": 1677,
    "limit": 120,
    "firstLine": 1677,
    "lastLine": 1796,
    "rawContent": "  1677→ * Animation de mort — la carte vole vers le cimetière (style Hearthstone/Arena)\n  1678→ * Phase 1 - Death Mark (400ms) : greyscale progressif + léger shrink\n  1679→ * Phase 2 - Fly to Graveyard (500ms) : vol vers le cimetière avec perspective tilt\n  1680→ */\n  1681→async function animateDeathToGraveyard(data) {\n  1682→    const owner = data.player === myNum ? 'me' : 'opp';\n  1683→    const ownerKey = owner;\n  1684→    const deathSlotKey = `${owner}-${data.row}-${data.col}`;\n  1685→\n  1686→    // graveRenderBlocked déjà incrémenté par queueAnimation — pas de double add\n  1687→\n  1688→    // 1. Trouver le slot et la carte\n  1689→    const slot = document.querySelector(\n  1690→        `.card-slot[data-owner=\"${owner}\"][data-row=\"${data.row}\"][data-col=\"${data.col}\"]`\n  1691→    );\n  1692→    const cardEl = slot?.querySelector('.card');\n  1693→\n  1694→    if (!slot) {\n  1695→        graveRenderBlocked.delete(ownerKey);\n  1696→        animatingSlots.delete(deathSlotKey);\n  1697→        return;\n  1698→    }\n  1699→\n  1700→    // 2. Positions de départ (slot sur le battlefield)\n  1701→    // Dimensions CSS fixes — getBoundingClientRect retourne la projection 2D après le tilt du board\n  1702→    const slotRect = slot.getBoundingClientRect();\n  1703→    const cardWidth = 140;\n  1704→    const cardHeight = 189;\n  1705→    // Centrer la carte fixe sur le centre visuel du slot\n  1706→    const startX = slotRect.left + slotRect.width / 2 - cardWidth / 2;\n  1707→    const startY = slotRect.top + slotRect.height / 2 - cardHeight / 2;\n  1708→\n  1709→    // 3. Position cible : cimetière du propriétaire — utiliser grave-top pour dimensions EXACTES\n  1710→    const graveEl = document.getElementById(owner === 'me' ? 'me-grave-box' : 'opp-grave-box');\n  1711→    const deathGraveTop = document.getElementById(`${ownerKey}-grave-top`);\n  1712→    let graveX = startX;\n  1713→    let graveY = startY + 200;\n  1714→    let graveScaleX = 1.0, graveScaleY = 1.0;\n  1715→    if (deathGraveTop) {\n  1716→        const tRect = deathGraveTop.getBoundingClientRect();\n  1717→        graveX = tRect.left + tRect.width / 2 - cardWidth / 2;\n  1718→        graveY = tRect.top + tRect.height / 2 - cardHeight / 2;\n  1719→        graveScaleX = tRect.width / cardWidth;\n  1720→        graveScaleY = tRect.height / cardHeight;\n  1721→    } else if (graveEl) {\n  1722→        const gRect = graveEl.getBoundingClientRect();\n  1723→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  1724→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  1725→        graveScaleX = gRect.width / cardWidth;\n  1726→        graveScaleY = gRect.height / cardHeight;\n  1727→    }\n  1728→\n  1729→    // 4. Créer le wrapper avec la carte\n  1730→    const wrapper = document.createElement('div');\n  1731→    wrapper.style.cssText = `\n  1732→        position: fixed; z-index: 10000; pointer-events: none;\n  1733→        left: ${startX}px; top: ${startY}px;\n  1734→        width: ${cardWidth}px; height: ${cardHeight}px;\n  1735→        transform-origin: center center;\n  1736→        transform: scale(1); opacity: 1;\n  1737→    `;\n  1738→\n  1739→    // Créer la face de la carte\n  1740→    let cardFace;\n  1741→    if (data.card && typeof makeCard === 'function') {\n  1742→        cardFace = makeCard(data.card, false);\n  1743→    } else if (cardEl) {\n  1744→        cardFace = cardEl.cloneNode(true);\n  1745→    } else {\n  1746→        graveRenderBlocked.delete(ownerKey);\n  1747→        animatingSlots.delete(deathSlotKey);\n  1748→        return;\n  1749→    }\n  1750→    const bgImage = cardFace.style.backgroundImage;\n  1751→    cardFace.style.position = 'absolute';\n  1752→    cardFace.style.top = '0';\n  1753→    cardFace.style.left = '0';\n  1754→    cardFace.style.width = cardWidth + 'px';\n  1755→    cardFace.style.height = cardHeight + 'px';\n  1756→    cardFace.style.margin = '0';\n  1757→    if (bgImage) cardFace.style.backgroundImage = bgImage;\n  1758→    // Forcer les tailles board sur les stats (la carte n'est plus dans .card-slot → CSS réduit les stats)\n  1759→    cardFace.querySelectorAll('.arena-atk, .arena-hp, .arena-armor').forEach(el => {\n  1760→        el.style.width = '30px';\n  1761→        el.style.height = '30px';\n  1762→        el.style.fontSize = '20px';\n  1763→        el.style.borderWidth = '2px';\n  1764→    });\n  1765→    wrapper.appendChild(cardFace);\n  1766→\n  1767→    // 5. Retirer la carte originale du slot immédiatement\n  1768→    if (cardEl) {\n  1769→        cardEl.remove();\n  1770→    }\n  1771→    slot.classList.remove('has-card');\n  1772→    slot.classList.remove('has-flying');\n  1773→\n  1774→    // Débloquer le slot — la carte est maintenant dans le wrapper volant, render() peut toucher le slot\n  1775→    animatingSlots.delete(deathSlotKey);\n  1776→\n  1777→    // 6. Perspective container (même technique que animateBurn)\n  1778→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  1779→    let perspContainer = null;\n  1780→    let graveTiltDeg = 0;\n  1781→    if (gameBoardWrapper) {\n  1782→        const gameBoard = document.querySelector('.game-board');\n  1783→        if (gameBoard) {\n  1784→            const computedTransform = getComputedStyle(gameBoard).transform;\n  1785→            if (computedTransform && computedTransform !== 'none') {\n  1786→                const mat = new DOMMatrix(computedTransform);\n  1787→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  1788→            }\n  1789→        }\n  1790→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  1791→        perspContainer = document.createElement('div');\n  1792→        perspContainer.dataset.animBorn = Date.now();\n  1793→        perspContainer.style.cssText = `\n  1794→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  1795→            z-index: 10000; pointer-events: none;\n  1796→            perspective: 1500px;"
  },
  {
    "transcriptLine": 215,
    "offset": 1796,
    "limit": 220,
    "firstLine": 1796,
    "lastLine": 2015,
    "rawContent": "  1796→            perspective: 1500px;\n  1797→            perspective-origin: ${gbwRect.left + gbwRect.width / 2}px ${gbwRect.top + gbwRect.height / 2}px;\n  1798→        `;\n  1799→        document.body.appendChild(perspContainer);\n  1800→        perspContainer.appendChild(wrapper);\n  1801→    } else {\n  1802→        document.body.appendChild(wrapper);\n  1803→    }\n  1804→\n  1805→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  1806→    if (deathGraveTop) {\n  1807→        const savedLeft = wrapper.style.left;\n  1808→        const savedTop = wrapper.style.top;\n  1809→        const savedTransform = wrapper.style.transform;\n  1810→        const target = deathGraveTop.getBoundingClientRect();\n  1811→        for (let pass = 0; pass < 3; pass++) {\n  1812→            wrapper.style.left = graveX + 'px';\n  1813→            wrapper.style.top = graveY + 'px';\n  1814→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  1815→            const m = wrapper.getBoundingClientRect();\n  1816→            if (m.width > 0 && m.height > 0) {\n  1817→                graveScaleX *= target.width / m.width;\n  1818→                graveScaleY *= target.height / m.height;\n  1819→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  1820→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  1821→            }\n  1822→\n  1823→        }\n  1824→        wrapper.style.left = savedLeft;\n  1825→        wrapper.style.top = savedTop;\n  1826→        wrapper.style.transform = savedTransform;\n  1827→    }\n  1828→\n  1829→    // Auto-fit du nom (les noms longs débordent pendant l'animation)\n  1830→    const deathNameFit = cardFace.querySelector('.arena-name');\n  1831→    if (deathNameFit) fitArenaName(deathNameFit);\n  1832→\n  1833→    // Pré-charger l'image de la carte pour l'effet de dissipation\n  1834→    let dissipCardImage = null;\n  1835→    let dissipationStarted = false;\n  1836→    const isDissipation = data.card?.abilities?.includes('dissipation');\n  1837→    if (isDissipation) {\n  1838→        const bgUrl = (cardFace.style.backgroundImage || '')\n  1839→            .replace(/^url\\([\"']?/, '').replace(/[\"']?\\)$/, '');\n  1840→        if (bgUrl) {\n  1841→            dissipCardImage = new Image();\n  1842→            dissipCardImage.src = bgUrl;\n  1843→        }\n  1844→    }\n  1845→\n  1846→    // 7. Animation\n  1847→    const deathMarkDuration = 400;\n  1848→    const flyDuration = 500;\n  1849→    const totalDuration = deathMarkDuration + flyDuration;\n  1850→\n  1851→    await new Promise(resolve => {\n  1852→        const startTime = performance.now();\n  1853→\n  1854→        const safetyTimeout = setTimeout(() => {\n  1855→            graveRenderBlocked.delete(ownerKey);\n  1856→            wrapper.remove();\n  1857→            if (perspContainer) perspContainer.remove();\n  1858→            resolve();\n  1859→        }, totalDuration + 500);\n  1860→\n  1861→        function animate() {\n  1862→            const elapsed = performance.now() - startTime;\n  1863→            const progress = Math.min(elapsed / totalDuration, 1);\n  1864→\n  1865→            const t1 = deathMarkDuration / totalDuration;\n  1866→\n  1867→            let x, y, scaleX, scaleY, opacity, greyAmount, tiltDeg;\n  1868→\n  1869→            if (progress <= t1) {\n  1870→                // === PHASE 1: DEATH MARK ===\n  1871→                const p = progress / t1;\n  1872→                const ep = easeOutCubic(p);\n  1873→                x = startX;\n  1874→                y = startY;\n  1875→                scaleX = scaleY = isDissipation ? 1.0 : 1.0 - ep * 0.05;\n  1876→                opacity = 1.0;\n  1877→                greyAmount = ep;\n  1878→                tiltDeg = graveTiltDeg;\n  1879→            } else if (isDissipation && !dissipationStarted) {\n  1880→                // === PHASE 2 (DISSIPATION): DÉSINTÉGRATION EN FRAGMENTS CANVAS ===\n  1881→                dissipationStarted = true;\n  1882→                clearTimeout(safetyTimeout);\n  1883→\n  1884→                // Créer le canvas source : image cover + bordure arrondie\n  1885→                const srcRes = 2;\n  1886→                const sourceCanvas = document.createElement('canvas');\n  1887→                sourceCanvas.width = cardWidth * srcRes;\n  1888→                sourceCanvas.height = cardHeight * srcRes;\n  1889→                const sctx = sourceCanvas.getContext('2d');\n  1890→                const sw = sourceCanvas.width, sh = sourceCanvas.height;\n  1891→                const borderR = 4 * srcRes;\n  1892→                const brdW = 2 * srcRes;\n  1893→\n  1894→                // Fond de bordure\n  1895→                sctx.fillStyle = '#353535';\n  1896→                sctx.beginPath();\n  1897→                sctx.roundRect(0, 0, sw, sh, borderR);\n  1898→                sctx.fill();\n  1899→\n  1900→                // Clipper l'intérieur et dessiner l'image avec cover positioning\n  1901→                sctx.save();\n  1902→                sctx.beginPath();\n  1903→                sctx.roundRect(brdW, brdW, sw - brdW * 2, sh - brdW * 2, borderR - brdW);\n  1904→                sctx.clip();\n  1905→                sctx.filter = 'grayscale(1) brightness(0.7)';\n  1906→                if (dissipCardImage && dissipCardImage.complete && dissipCardImage.naturalWidth) {\n  1907→                    const imgW = dissipCardImage.naturalWidth;\n  1908→                    const imgH = dissipCardImage.naturalHeight;\n  1909→                    const areaW = sw - brdW * 2;\n  1910→                    const areaH = sh - brdW * 2;\n  1911→                    const scale = Math.max(areaW / imgW, areaH / imgH);\n  1912→                    const drawW = imgW * scale;\n  1913→                    const drawH = imgH * scale;\n  1914→                    const drawX = brdW + (areaW - drawW) / 2;\n  1915→                    const drawY = brdW + (areaH - drawH) / 2;\n  1916→                    sctx.drawImage(dissipCardImage, drawX, drawY, drawW, drawH);\n  1917→                }\n  1918→                sctx.restore();\n  1919→\n  1920→                // Rendre transparent hors bordure arrondie\n  1921→                sctx.globalCompositeOperation = 'destination-in';\n  1922→                sctx.beginPath();\n  1923→                sctx.roundRect(0, 0, sw, sh, borderR);\n  1924→                sctx.fill();\n  1925→                sctx.globalCompositeOperation = 'source-over';\n  1926→\n  1927→                // Position visuelle du wrapper (décalée par tilt + perspective)\n  1928→                const wrapperRect = wrapper.getBoundingClientRect();\n  1929→                wrapper.style.visibility = 'hidden';\n  1930→\n  1931→                // Passer cardWidth/cardHeight originaux — pas wrapperRect (compressé par le tilt = double déformation)\n  1932→                animateDissipationVanish(sourceCanvas, wrapperRect.left, wrapperRect.top, cardWidth, cardHeight, graveTiltDeg, perspContainer).then(() => {\n  1933→                    wrapper.remove();\n  1934→                    if (perspContainer) perspContainer.remove();\n  1935→                    graveRenderBlocked.delete(ownerKey);\n  1936→                    resolve();\n  1937→                });\n  1938→                return;\n  1939→            } else if (isDissipation) {\n  1940→                // Dissipation déjà lancée — ne rien faire\n  1941→                return;\n  1942→            } else {\n  1943→                // === PHASE 2: FLY TO GRAVEYARD ===\n  1944→                const p = (progress - t1) / (1 - t1);\n  1945→                const ep = easeInOutCubic(p);\n  1946→                x = startX + (graveX - startX) * ep;\n  1947→                y = startY + (graveY - startY) * ep;\n  1948→                scaleX = 0.95 + (graveScaleX - 0.95) * ep;\n  1949→                scaleY = 0.95 + (graveScaleY - 0.95) * ep;\n  1950→                opacity = 1;\n  1951→                greyAmount = 1.0;\n  1952→                tiltDeg = graveTiltDeg;\n  1953→            }\n  1954→\n  1955→            wrapper.style.left = x + 'px';\n  1956→            wrapper.style.top = y + 'px';\n  1957→            wrapper.style.opacity = opacity;\n  1958→            wrapper.style.transform = `scale(${scaleX}, ${scaleY}) rotateX(${tiltDeg}deg)`;\n  1959→\n  1960→            // Effet visuel de mort : greyscale + darkening\n  1961→            if (greyAmount > 0) {\n  1962→                wrapper.style.filter = `grayscale(${greyAmount}) brightness(${1 - greyAmount * 0.3})`;\n  1963→            } else {\n  1964→                wrapper.style.filter = 'none';\n  1965→            }\n  1966→\n  1967→            if (progress < 1) {\n  1968→                requestAnimationFrame(animate);\n  1969→            } else {\n  1970→                clearTimeout(safetyTimeout);\n  1971→\n  1972→                // Cacher le wrapper AVANT de placer la carte (même frame synchrone = pas de pop)\n  1973→                wrapper.style.visibility = 'hidden';\n  1974→\n  1975→                // Placer la carte directement dans le cimetière via data.card\n  1976→                // Le state n'est pas encore à jour (graveyard.length=0), donc on\n  1977→                // utilise la carte de l'animation pour pré-remplir le cimetière\n  1978→                // Dissipation : pas de placement au cimetière\n  1979→                graveRenderBlocked.delete(ownerKey);\n  1980→                const isDissip = data.card?.abilities?.includes('dissipation');\n  1981→                if (data.card && !isDissip) {\n  1982→                    const container = document.getElementById(`${ownerKey}-grave-top`);\n  1983→                    if (container) {\n  1984→                        const topId = data.card.uid || data.card.id;\n  1985→                        container.dataset.topCardUid = topId;\n  1986→                        container.classList.remove('empty');\n  1987→                        container.innerHTML = '';\n  1988→                        const cardEl = makeCard(data.card, false);\n  1989→                        cardEl.classList.remove('just-played', 'can-attack', 'melody-locked', 'petrified');\n  1990→                        // Nettoyer les effets Medusa (la carte au cimetière est reset)\n  1991→                        const gazeMarkerEl = cardEl.querySelector('.gaze-marker');\n  1992→                        if (gazeMarkerEl) gazeMarkerEl.remove();\n  1993→                        cardEl.classList.add('grave-card', 'in-graveyard');\n  1994→                        container.appendChild(cardEl);\n  1995→                        const nameEl = cardEl.querySelector('.arena-name');\n  1996→                        if (nameEl) fitArenaName(nameEl);\n  1997→                    }\n  1998→                    // Aussi mettre à jour le stack\n  1999→                    const graveyard = owner === 'me' ? state?.me?.graveyard : state?.opponent?.graveyard;\n  2000→                    updateGraveDisplay(ownerKey, graveyard || [data.card]);\n  2001→\n  2002→                    // Mise à jour dynamique de la popup cimetière\n  2003→                    addCardToGraveyardPopup(ownerKey, data.card);\n  2004→                }\n  2005→\n  2006→                // Retirer le wrapper au prochain frame\n  2007→                requestAnimationFrame(() => {\n  2008→                    wrapper.remove();\n  2009→                    if (perspContainer) perspContainer.remove();\n  2010→                });\n  2011→                resolve();\n  2012→            }\n  2013→        }\n  2014→\n  2015→        requestAnimationFrame(animate);"
  },
  {
    "transcriptLine": 230,
    "offset": 2297,
    "limit": 180,
    "firstLine": 2297,
    "lastLine": 2476,
    "rawContent": "  2297→    return el;\n  2298→}\n  2299→\n  2300→/**\n  2301→ * Animation de révélation d'un sort ou piège — style Hearthstone/Arena\n  2302→ * La carte apparaît en grand (gauche = joueur, droite = adversaire)\n  2303→ * puis vole vers le cimetière du propriétaire.\n  2304→ */\n  2305→async function animateSpellReveal(card, casterPlayerNum, startRect = null) {\n  2306→    const isMine = casterPlayerNum === myNum;\n  2307→    const side = isMine ? 'me' : 'opp';\n  2308→    const cardWidth = 140;\n  2309→    const cardHeight = 189;\n  2310→\n  2311→    // graveRenderBlocked déjà incrémenté par queueAnimation — pas de double add\n  2312→\n  2313→    // 1. Créer l'élément carte (version complète avec description pour la révélation)\n  2314→    const cardEl = (typeof makeCard === 'function')\n  2315→        ? makeCard(card, true)\n  2316→        : createCardElementForAnimation(card);\n  2317→    cardEl.classList.remove('just-played', 'can-attack');\n  2318→    const bgImage = cardEl.style.backgroundImage;\n  2319→    cardEl.style.position = 'absolute';\n  2320→    cardEl.style.top = '0';\n  2321→    cardEl.style.left = '0';\n  2322→    cardEl.style.width = '100%';\n  2323→    cardEl.style.height = '100%';\n  2324→    cardEl.style.margin = '0';\n  2325→    if (bgImage) cardEl.style.backgroundImage = bgImage;\n  2326→\n  2327→    // 2. Calculer la position showcase (gauche ou droite du game-board)\n  2328→    const gameBoard = document.querySelector('.game-board');\n  2329→    if (!gameBoard) return;\n  2330→    const gbRect = gameBoard.getBoundingClientRect();\n  2331→    const showcaseScale = 1.8;\n  2332→    const showcaseX = isMine\n  2333→        ? gbRect.left + gbRect.width * 0.20 - (cardWidth * showcaseScale) / 2\n  2334→        : gbRect.left + gbRect.width * 0.80 - (cardWidth * showcaseScale) / 2;\n  2335→    const showcaseY = gbRect.top + gbRect.height * 0.45 - (cardHeight * showcaseScale) / 2;\n  2336→\n  2337→    // 3. Calculer la position du cimetière du caster — utiliser grave-top pour dimensions EXACTES\n  2338→    const graveEl = document.getElementById(side + '-grave-box');\n  2339→    const spellGraveTop = document.getElementById(side + '-grave-top');\n  2340→    let graveX = showcaseX;\n  2341→    let graveY = showcaseY + 200;\n  2342→    let graveScaleX = 1.0, graveScaleY = 1.0;\n  2343→    if (spellGraveTop) {\n  2344→        const tRect = spellGraveTop.getBoundingClientRect();\n  2345→        graveX = tRect.left + tRect.width / 2 - cardWidth / 2;\n  2346→        graveY = tRect.top + tRect.height / 2 - cardHeight / 2;\n  2347→        graveScaleX = tRect.width / cardWidth;\n  2348→        graveScaleY = tRect.height / cardHeight;\n  2349→    } else if (graveEl) {\n  2350→        const gRect = graveEl.getBoundingClientRect();\n  2351→        graveX = gRect.left + gRect.width / 2 - cardWidth / 2;\n  2352→        graveY = gRect.top + gRect.height / 2 - cardHeight / 2;\n  2353→        graveScaleX = gRect.width / cardWidth;\n  2354→        graveScaleY = gRect.height / cardHeight;\n  2355→    }\n  2356→\n  2357→    // 4. Position de départ : depuis la main (startRect) ou materialisation classique\n  2358→    const hasStartRect = !!startRect;\n  2359→    // Sort adverse sans startRect : flip 3D (dos → face) à la position showcase\n  2360→    const isOppFlip = !isMine && !hasStartRect;\n  2361→    // Mes sorts : le wrapper démarre à showcaseScale (net), un clone léger fait le vol depuis la main\n  2362→    const isMyFly = isMine && hasStartRect;\n  2363→\n  2364→    // Le wrapper démarre TOUJOURS à la position/scale showcase (rasterisation nette)\n  2365→    const wrapper = document.createElement('div');\n  2366→    wrapper.style.cssText = `\n  2367→        position: fixed; z-index: 10000; pointer-events: none;\n  2368→        left: ${showcaseX}px; top: ${showcaseY}px;\n  2369→        width: ${cardWidth}px; height: ${cardHeight}px;\n  2370→        transform-origin: center center;\n  2371→        transform: scale(${showcaseScale}); opacity: ${(isOppFlip || isMyFly) ? 1 : 0};\n  2372→        perspective: 800px;\n  2373→    `;\n  2374→    // Mes sorts : wrapper caché pendant le vol, révélé à l'arrivée\n  2375→    if (isMyFly) {\n  2376→        wrapper.style.opacity = '0';\n  2377→    }\n  2378→\n  2379→    // Sort adverse : structure flipper (dos + face) pour le flip 3D\n  2380→    let flipper = null;\n  2381→    if (isOppFlip) {\n  2382→        flipper = document.createElement('div');\n  2383→        flipper.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;transform-style:preserve-3d;';\n  2384→\n  2385→        // Dos de carte\n  2386→        const backFace = document.createElement('div');\n  2387→        backFace.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;backface-visibility:hidden;border-radius:6px;overflow:hidden;';\n  2388→        const backImg = document.createElement('img');\n  2389→        backImg.src = 'cardback/back_1.png';\n  2390→        backImg.style.cssText = 'width:100%;height:100%;display:block;';\n  2391→        backFace.appendChild(backImg);\n  2392→\n  2393→        // Face du sort (commence retournée, invisible)\n  2394→        cardEl.style.backfaceVisibility = 'hidden';\n  2395→        cardEl.style.transform = 'rotateY(180deg)';\n  2396→\n  2397→        flipper.appendChild(backFace);\n  2398→        flipper.appendChild(cardEl);\n  2399→        wrapper.appendChild(flipper);\n  2400→    } else {\n  2401→        wrapper.appendChild(cardEl);\n  2402→    }\n  2403→\n  2404→    // Mes sorts : clone léger qui vole de la main vers le showcase (même taille de base, scale pour grandir)\n  2405→    let flyClone = null;\n  2406→    let flyStartScale = 1;\n  2407→    if (isMyFly) {\n  2408→        // Taille de base = cardWidth × cardHeight, scale pour matcher la taille de la main\n  2409→        flyStartScale = startRect.width / cardWidth;\n  2410→        const startCX = startRect.left + startRect.width / 2;\n  2411→        const startCY = startRect.top + startRect.height / 2;\n  2412→        flyClone = document.createElement('div');\n  2413→        flyClone.style.cssText = `\n  2414→            position: fixed; z-index: 10001; pointer-events: none;\n  2415→            left: ${startCX - cardWidth / 2}px; top: ${startCY - cardHeight / 2}px;\n  2416→            width: ${cardWidth}px; height: ${cardHeight}px;\n  2417→            border-radius: 6px; overflow: hidden;\n  2418→            transform-origin: center center;\n  2419→            transform: scale(${flyStartScale});\n  2420→        `;\n  2421→        const flyCardEl = makeCard(card, true);\n  2422→        flyCardEl.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;margin:0;';\n  2423→        if (card.image) flyCardEl.style.backgroundImage = `url('/cards/${card.image}')`;\n  2424→        flyClone.appendChild(flyCardEl);\n  2425→        document.body.appendChild(flyClone);\n  2426→    }\n  2427→\n  2428→    // 5. Perspective container pour le fly-to-graveyard (même technique que animateBurn)\n  2429→    const gameBoardWrapper = document.querySelector('.game-board-wrapper');\n  2430→    let perspContainer = null;\n  2431→    let graveTiltDeg = 0;\n  2432→    if (gameBoardWrapper) {\n  2433→        const gb = document.querySelector('.game-board');\n  2434→        if (gb) {\n  2435→            const computedTransform = getComputedStyle(gb).transform;\n  2436→            if (computedTransform && computedTransform !== 'none') {\n  2437→                const mat = new DOMMatrix(computedTransform);\n  2438→                graveTiltDeg = Math.atan2(mat.m23, mat.m22) * (180 / Math.PI);\n  2439→            }\n  2440→        }\n  2441→        const gbwRect = gameBoardWrapper.getBoundingClientRect();\n  2442→        perspContainer = document.createElement('div');\n  2443→        perspContainer.dataset.animBorn = Date.now();\n  2444→        perspContainer.style.cssText = `\n  2445→            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;\n  2446→            z-index: 10000; pointer-events: none;\n  2447→            perspective: 1500px;\n  2448→            perspective-origin: ${gbwRect.left + gbwRect.width / 2}px ${gbwRect.top + gbwRect.height / 2}px;\n  2449→        `;\n  2450→        document.body.appendChild(perspContainer);\n  2451→        perspContainer.appendChild(wrapper);\n  2452→    } else {\n  2453→        document.body.appendChild(wrapper);\n  2454→    }\n  2455→\n  2456→    // Calibrer graveScaleX/Y : 3 passes itératives, correction indépendante W et H\n  2457→    if (spellGraveTop) {\n  2458→        const savedLeft = wrapper.style.left;\n  2459→        const savedTop = wrapper.style.top;\n  2460→        const savedTransform = wrapper.style.transform;\n  2461→        const savedOpacity = wrapper.style.opacity;\n  2462→        wrapper.style.opacity = '0';\n  2463→        const target = spellGraveTop.getBoundingClientRect();\n  2464→        for (let pass = 0; pass < 3; pass++) {\n  2465→            wrapper.style.left = graveX + 'px';\n  2466→            wrapper.style.top = graveY + 'px';\n  2467→            wrapper.style.transform = `scale(${graveScaleX}, ${graveScaleY}) rotateX(${graveTiltDeg}deg)`;\n  2468→            const m = wrapper.getBoundingClientRect();\n  2469→            if (m.width > 0 && m.height > 0) {\n  2470→                graveScaleX *= target.width / m.width;\n  2471→                graveScaleY *= target.height / m.height;\n  2472→                graveX += (target.left + target.width / 2) - (m.left + m.width / 2);\n  2473→                graveY += (target.top + target.height / 2) - (m.top + m.height / 2);\n  2474→            }\n  2475→        }\n  2476→        wrapper.style.left = savedLeft;"
  },
  {
    "transcriptLine": 232,
    "offset": 2476,
    "limit": 210,
    "firstLine": 2476,
    "lastLine": 2685,
    "rawContent": "  2476→        wrapper.style.left = savedLeft;\n  2477→        wrapper.style.top = savedTop;\n  2478→        wrapper.style.transform = savedTransform;\n  2479→        wrapper.style.opacity = savedOpacity;\n  2480→    }\n  2481→\n  2482→    // Auto-fit du nom (les noms longs débordent pendant l'animation)\n  2483→    const spellNameFit = cardEl.querySelector('.arena-name');\n  2484→    if (spellNameFit) fitArenaName(spellNameFit);\n  2485→\n  2486→    // 6. Durées des phases (pas de phase impact — le fly est la dernière, comme burn)\n  2487→    const materializeDuration = 300;\n  2488→    const holdDuration = 1000;\n  2489→    const shrinkDuration = 300;\n  2490→    const flyDuration = 400;\n  2491→    const totalDuration = materializeDuration + holdDuration + shrinkDuration + flyDuration;\n  2492→\n  2493→    await new Promise(resolve => {\n  2494→        const startTime = performance.now();\n  2495→        const safetyTimeout = setTimeout(() => {\n  2496→            graveRenderBlocked.delete(side);\n  2497→            wrapper.remove();\n  2498→            if (flyClone) flyClone.remove();\n  2499→            if (perspContainer) perspContainer.remove();\n  2500→            resolve();\n  2501→        }, totalDuration + 1000);\n  2502→\n  2503→        function animate() {\n  2504→            const elapsed = performance.now() - startTime;\n  2505→            const progress = Math.min(elapsed / totalDuration, 1);\n  2506→\n  2507→            const t1 = materializeDuration / totalDuration;\n  2508→            const t2 = (materializeDuration + holdDuration) / totalDuration;\n  2509→            const t3 = (materializeDuration + holdDuration + shrinkDuration) / totalDuration;\n  2510→\n  2511→            let x, y, scaleX, scaleY, opacity, tiltDeg;\n  2512→\n  2513→            if (progress <= t1) {\n  2514→                // === PHASE 1: MATERIALIZE / FLIP / FLY ===\n  2515→                const p = progress / t1;\n  2516→                if (isOppFlip && flipper) {\n  2517→                    // Sort adverse : flip 3D dos → face\n  2518→                    const ep = easeInOutCubic(p);\n  2519→                    flipper.style.transform = `rotateY(${ep * 180}deg)`;\n  2520→                    x = showcaseX;\n  2521→                    y = showcaseY;\n  2522→                    scaleX = scaleY = showcaseScale;\n  2523→                    opacity = 1;\n  2524→                    tiltDeg = 0;\n  2525→                } else if (isMyFly && flyClone) {\n  2526→                    // Mes sorts : le clone vole de la main vers le showcase via scale (proportions uniformes)\n  2527→                    const ep = easeInOutCubic(p);\n  2528→                    // Interpoler les centres\n  2529→                    const startCX = startRect.left + startRect.width / 2;\n  2530→                    const startCY = startRect.top + startRect.height / 2;\n  2531→                    const endCX = showcaseX + cardWidth / 2;\n  2532→                    const endCY = showcaseY + cardHeight / 2;\n  2533→                    const cx = startCX + (endCX - startCX) * ep;\n  2534→                    const cy = startCY + (endCY - startCY) * ep;\n  2535→                    const currentScale = flyStartScale + (showcaseScale - flyStartScale) * ep;\n  2536→                    flyClone.style.left = (cx - cardWidth / 2) + 'px';\n  2537→                    flyClone.style.top = (cy - cardHeight / 2) + 'px';\n  2538→                    flyClone.style.transform = `scale(${currentScale})`;\n  2539→                    flyClone.style.opacity = (0.85 + 0.15 * ep);\n  2540→                    // Wrapper reste caché pendant le vol\n  2541→                    x = showcaseX;\n  2542→                    y = showcaseY;\n  2543→                    scaleX = scaleY = showcaseScale;\n  2544→                    opacity = 0;\n  2545→                    tiltDeg = 0;\n  2546→                } else {\n  2547→                    // Fallback materialisation\n  2548→                    const ep = easeOutBack(p);\n  2549→                    x = showcaseX;\n  2550→                    y = showcaseY;\n  2551→                    scaleX = scaleY = 0.3 + (showcaseScale - 0.3) * ep;\n  2552→                    opacity = easeOutCubic(p);\n  2553→                    tiltDeg = 0;\n  2554→                }\n  2555→\n  2556→            } else if (progress <= t2) {\n  2557→                // === PHASE 2: HOLD / SHOWCASE ===\n  2558→                // Nettoyer le flipper : remettre cardEl directement dans le wrapper\n  2559→                if (flipper && flipper.parentElement) {\n  2560→                    cardEl.style.backfaceVisibility = '';\n  2561→                    cardEl.style.transform = '';\n  2562→                    wrapper.removeChild(flipper);\n  2563→                    wrapper.appendChild(cardEl);\n  2564→                    flipper = null;\n  2565→                }\n  2566→                // Nettoyer le flyClone : révéler le wrapper net\n  2567→                if (flyClone) {\n  2568→                    flyClone.remove();\n  2569→                    flyClone = null;\n  2570→                }\n  2571→                const p = (progress - t1) / (t2 - t1);\n  2572→                x = showcaseX;\n  2573→                y = showcaseY;\n  2574→                scaleX = scaleY = showcaseScale;\n  2575→                opacity = 1;\n  2576→                tiltDeg = 0;\n  2577→\n  2578→            } else if (progress <= t3) {\n  2579→                // === PHASE 3: SHRINK ===\n  2580→                const p = (progress - t2) / (t3 - t2);\n  2581→                const ep = easeInOutCubic(p);\n  2582→                x = showcaseX;\n  2583→                y = showcaseY;\n  2584→                scaleX = scaleY = showcaseScale + (1.0 - showcaseScale) * ep;\n  2585→                opacity = 1;\n  2586→                tiltDeg = 0;\n  2587→\n  2588→            } else {\n  2589→                // === PHASE 4: FLY TO GRAVEYARD (dernière phase, comme burn) ===\n  2590→                const p = (progress - t3) / (1 - t3);\n  2591→                const ep = easeInOutCubic(p);\n  2592→                x = showcaseX + (graveX - showcaseX) * ep;\n  2593→                y = showcaseY + (graveY - showcaseY) * ep;\n  2594→                scaleX = 1.0 + (graveScaleX - 1.0) * ep;\n  2595→                scaleY = 1.0 + (graveScaleY - 1.0) * ep;\n  2596→                opacity = 1;\n  2597→                tiltDeg = ep * graveTiltDeg;\n  2598→            }\n  2599→\n  2600→            wrapper.style.left = x + 'px';\n  2601→            wrapper.style.top = y + 'px';\n  2602→            wrapper.style.opacity = opacity;\n  2603→            wrapper.style.transform = `scale(${scaleX}, ${scaleY}) rotateX(${tiltDeg}deg)`;\n  2604→\n  2605→            if (progress < 1) {\n  2606→                requestAnimationFrame(animate);\n  2607→            } else {\n  2608→                clearTimeout(safetyTimeout);\n  2609→\n  2610→                // Cacher le wrapper AVANT de placer la carte (même frame synchrone = pas de pop)\n  2611→                wrapper.style.visibility = 'hidden';\n  2612→\n  2613→                const spellId = card.uid || card.id;\n  2614→\n  2615→                // Toujours placer la carte visuellement dans le cimetière\n  2616→                // (pour returnOnMiss, la carte reste visible ici jusqu'à l'animation de retour)\n  2617→                const graveTopContainer = document.getElementById(side + '-grave-top');\n  2618→                if (graveTopContainer) {\n  2619→                    graveTopContainer.dataset.topCardUid = spellId;\n  2620→                    graveTopContainer.classList.remove('empty');\n  2621→                    graveTopContainer.innerHTML = '';\n  2622→                    const graveCardEl = makeCard(card, false);\n  2623→                    graveCardEl.classList.remove('just-played', 'can-attack');\n  2624→                    graveCardEl.classList.add('grave-card', 'in-graveyard');\n  2625→                    graveTopContainer.appendChild(graveCardEl);\n  2626→                    const spellNameEl = graveCardEl.querySelector('.arena-name');\n  2627→                    if (spellNameEl) fitArenaName(spellNameEl);\n  2628→                }\n  2629→                // Mise à jour dynamique de la popup cimetière\n  2630→                if (!card.returnOnMiss) {\n  2631→                    addCardToGraveyardPopup(side, card);\n  2632→                }\n  2633→\n  2634→                // Mettre à jour les layers du cimetière progressivement (escalier)\n  2635→                // Le state est toujours 1 sort en retard (animation émise avant state),\n  2636→                // donc on utilise count = stateGrave.length + 1 et stateGrave pour les layers\n  2637→                if (!card.returnOnMiss) {\n  2638→                    const stateGrave = side === 'me' ? state?.me?.graveyard : state?.opponent?.graveyard;\n  2639→                    const stack = document.getElementById(`${side}-grave-stack`);\n  2640→                    if (stack) {\n  2641→                        // count = sorts déjà dans le state + le sort qu'on vient de placer\n  2642→                        const count = (stateGrave ? stateGrave.length : 0) + 1;\n  2643→                        stack.classList.toggle('has-cards', count > 0);\n  2644→                        const layers = stack.querySelectorAll('.grave-card-layer');\n  2645→                        const visibleLayers = count <= 1 ? 0 : Math.min(layers.length, Math.ceil(count / 6));\n  2646→                        stack.style.setProperty('--stack-layers', visibleLayers);\n  2647→                        layers.forEach((layer, i) => {\n  2648→                            const show = i >= layers.length - visibleLayers;\n  2649→                            layer.style.display = show ? 'block' : 'none';\n  2650→                            if (show && stateGrave) {\n  2651→                                const cardIndex = count - (3 - i) - 1;\n  2652→                                const layerCard = cardIndex >= 0 && cardIndex < stateGrave.length ? stateGrave[cardIndex] : null;\n  2653→                                const layerCardId = layerCard ? (layerCard.uid || layerCard.id) : '';\n  2654→                                if (layer.dataset.cardUid !== layerCardId) {\n  2655→                                    layer.dataset.cardUid = layerCardId;\n  2656→                                    layer.innerHTML = '';\n  2657→                                    if (layerCard) {\n  2658→                                        const layerEl = makeCard(layerCard, false);\n  2659→                                        layerEl.classList.add('grave-card', 'in-graveyard');\n  2660→                                        layer.appendChild(layerEl);\n  2661→                                    }\n  2662→                                }\n  2663→                            }\n  2664→                        });\n  2665→                    }\n  2666→                }\n  2667→\n  2668→                // GARDER graveRenderBlocked actif !\n  2669→                // Le state du serveur n'a pas encore le sort dans le cimetière.\n  2670→                // Si on débloque maintenant, render() voit un cimetière vide et efface notre carte.\n  2671→                // On débloque après un délai pour laisser le state se mettre à jour.\n  2672→                const capturedSide = side;\n  2673→                const spellUid = spellId;\n  2674→                setTimeout(() => {\n  2675→                    const graveyard = capturedSide === 'me' ? state?.me?.graveyard : state?.opponent?.graveyard;\n  2676→                    graveRenderBlocked.delete(capturedSide);\n  2677→                    if (state) {\n  2678→                        if (graveyard) {\n  2679→                            updateGraveDisplay(capturedSide, graveyard);\n  2680→                            updateGraveTopCard(capturedSide, graveyard);\n  2681→                        }\n  2682→                    }\n  2683→                }, 2000);\n  2684→\n  2685→                wrapper.remove();"
  },
  {
    "transcriptLine": 247,
    "offset": 2700,
    "limit": 80,
    "firstLine": 2700,
    "lastLine": 2779,
    "rawContent": "  2700→async function animateSpell(data) {\n  2701→    // Fly from opponent hand before revealing the spell\n  2702→    if (data.spell && data.caster !== myNum) {\n  2703→        const gameBoard = document.querySelector('.game-board');\n  2704→        if (gameBoard) {\n  2705→            const gbRect = gameBoard.getBoundingClientRect();\n  2706→            const cardW = 140, cardH = 189, sc = 1.8;\n  2707→            const showcaseX = gbRect.left + gbRect.width * 0.80 - (cardW * sc) / 2;\n  2708→            const showcaseY = gbRect.top + gbRect.height * 0.45 - (cardH * sc) / 2;\n  2709→            // Utiliser la position sauvegardée de la carte dans la main adverse (avant le rebuild)\n  2710→            const savedRect = (data.visualHandIndex >= 0 && savedOppHandRects)\n  2711→                ? savedOppHandRects[data.visualHandIndex] : null;\n  2712→            await flyFromOppHand({ left: showcaseX, top: showcaseY, width: cardW * sc, height: cardH * sc }, 300, data.spell, savedRect);\n  2713→        }\n  2714→    }\n  2715→    // Pour nos propres sorts : récupérer la position du sort engagé dans la main\n  2716→    let startRect = null;\n  2717→    if (data.spell && data.caster === myNum && committedSpells.length > 0) {\n  2718→        const handPanel = document.getElementById('my-hand');\n  2719→        const committedEls = handPanel ? handPanel.querySelectorAll('.committed-spell') : [];\n  2720→        const csIdx = committedSpells.findIndex(cs => cs.card.id === data.spell.id);\n  2721→        if (csIdx >= 0) {\n  2722→            const commitId = committedSpells[csIdx].commitId;\n  2723→            // Chercher l'élément DOM du sort engagé\n  2724→            let foundEl = null;\n  2725→            for (const el of committedEls) {\n  2726→                if (parseInt(el.dataset.commitId) === commitId) {\n  2727→                    foundEl = el;\n  2728→                    break;\n  2729→                }\n  2730→            }\n  2731→\n  2732→            if (foundEl) {\n  2733→                // Élément trouvé dans le DOM — récupérer sa position et le retirer\n  2734→                startRect = foundEl.getBoundingClientRect();\n  2735→\n  2736→                // FLIP : capturer les positions des cartes voisines AVANT de retirer le sort\n  2737→                const siblings = handPanel.querySelectorAll('.card');\n  2738→                const oldPositions = new Map();\n  2739→                for (const sibling of siblings) {\n  2740→                    if (sibling === foundEl) continue;\n  2741→                    oldPositions.set(sibling, sibling.getBoundingClientRect().left);\n  2742→                }\n  2743→\n  2744→                foundEl.remove();\n  2745→\n  2746→                // FLIP : animer les cartes restantes vers leurs nouvelles positions\n  2747→                const toAnimate = [];\n  2748→                for (const [card, oldLeft] of oldPositions) {\n  2749→                    if (!card.isConnected) continue;\n  2750→                    const dx = oldLeft - card.getBoundingClientRect().left;\n  2751→                    if (Math.abs(dx) > 1) {\n  2752→                        card.style.transition = 'none';\n  2753→                        card.style.transform = `translateX(${dx}px)`;\n  2754→                        toAnimate.push(card);\n  2755→                    }\n  2756→                }\n  2757→                if (toAnimate.length > 0) {\n  2758→                    handPanel.getBoundingClientRect(); // force reflow\n  2759→                    requestAnimationFrame(() => {\n  2760→                        requestAnimationFrame(() => {\n  2761→                            toAnimate.forEach(card => {\n  2762→                                card.style.transition = 'transform 0.3s ease-out';\n  2763→                                card.style.transform = '';\n  2764→                            });\n  2765→                            setTimeout(() => {\n  2766→                                toAnimate.forEach(card => { card.style.transition = ''; });\n  2767→                            }, 350);\n  2768→                        });\n  2769→                    });\n  2770→                }\n  2771→            } else if (cachedCommittedRects[commitId]) {\n  2772→                // Élément déjà retiré du DOM — utiliser la position cachée (par commitId, unique)\n  2773→                startRect = cachedCommittedRects[commitId];\n  2774→            }\n  2775→\n  2776→            committedSpells.splice(csIdx, 1);\n  2777→            delete cachedCommittedRects[commitId];\n  2778→        }\n  2779→    }"
  },
  {
    "transcriptLine": 253,
    "offset": 3845,
    "limit": 80,
    "firstLine": 3845,
    "lastLine": 3924,
    "rawContent": "  3845→function flyFromOppHand(targetRect, duration = 300, spell = null, savedSourceRect = null) {\n  3846→    return new Promise(resolve => {\n  3847→        let handRect = savedSourceRect;\n  3848→\n  3849→        if (!handRect) {\n  3850→            const handPanel = document.getElementById('opp-hand');\n  3851→            const handCards = handPanel ? handPanel.querySelectorAll('.opp-card-back') : [];\n  3852→\n  3853→            // Pour une carte revealed, trouver sa position exacte dans la main via son uid\n  3854→            let sourceCard = handCards[handCards.length - 1];\n  3855→            if (spell && spell.uid) {\n  3856→                const match = handPanel?.querySelector(`.opp-revealed[data-uid=\"${spell.uid}\"]`);\n  3857→                if (match) sourceCard = match;\n  3858→            }\n  3859→\n  3860→            if (!sourceCard) { resolve(); return; }\n  3861→            handRect = sourceCard.getBoundingClientRect();\n  3862→        }\n  3863→\n  3864→        // Cacher la carte revealed dans la main (elle va être remplacée par le clone volant)\n  3865→        if (spell && spell.uid) {\n  3866→            const handPanel = document.getElementById('opp-hand');\n  3867→            const match = handPanel?.querySelector(`.opp-revealed[data-uid=\"${spell.uid}\"]`);\n  3868→            if (match) {\n  3869→                match.style.visibility = 'hidden';\n  3870→            }\n  3871→        }\n  3872→\n  3873→        // Créer la carte volante directement à la taille cible (comme un drag)\n  3874→        const fw = targetRect.width, fh = targetRect.height;\n  3875→        const flyCard = document.createElement('div');\n  3876→        flyCard.style.cssText = `\n  3877→            position: fixed; z-index: 10001; pointer-events: none; overflow: hidden;\n  3878→            left: ${handRect.left + handRect.width / 2 - fw / 2}px;\n  3879→            top: ${handRect.top + handRect.height / 2 - fh / 2}px;\n  3880→            width: ${fw}px; height: ${fh}px;\n  3881→            border-radius: 6px;\n  3882→            box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n  3883→        `;\n  3884→        if (spell && spell.revealedToOpponent && typeof makeCard === 'function') {\n  3885→            const cardFace = makeCard(spell, false);\n  3886→            const bgImage = cardFace.style.backgroundImage;\n  3887→            cardFace.style.width = '100%';\n  3888→            cardFace.style.height = '100%';\n  3889→            cardFace.style.margin = '0';\n  3890→            cardFace.style.position = 'relative';\n  3891→            cardFace.style.borderRadius = '6px';\n  3892→            flyCard.appendChild(cardFace);\n  3893→        } else {\n  3894→            const flyImg = document.createElement('img');\n  3895→            flyImg.src = 'cardback/back_1.png';\n  3896→            flyImg.style.cssText = 'width: 100%; height: 100%; display: block;';\n  3897→            flyCard.appendChild(flyImg);\n  3898→        }\n  3899→        document.body.appendChild(flyCard);\n  3900→\n  3901→        // Trajectoire par centres\n  3902→        const scx = handRect.left + handRect.width / 2;\n  3903→        const scy = handRect.top + handRect.height / 2;\n  3904→        const ecx = targetRect.left + fw / 2;\n  3905→        const ecy = targetRect.top + fh / 2;\n  3906→        const ccx = (scx + ecx) / 2;\n  3907→        const ccy = Math.max(scy, ecy) + 50;\n  3908→\n  3909→        const t0 = performance.now();\n  3910→        function animate() {\n  3911→            const p = Math.min((performance.now() - t0) / duration, 1);\n  3912→            const t = easeInOutCubic(p);\n  3913→\n  3914→            // Centre sur la courbe de Bézier\n  3915→            const cx = (1-t)*(1-t)*scx + 2*(1-t)*t*ccx + t*t*ecx;\n  3916→            const cy = (1-t)*(1-t)*scy + 2*(1-t)*t*ccy + t*t*ecy;\n  3917→\n  3918→            // Convertir centre → top-left (taille fixe)\n  3919→            flyCard.style.left = (cx - fw / 2) + 'px';\n  3920→            flyCard.style.top = (cy - fh / 2) + 'px';\n  3921→            flyCard.style.opacity = (1 - t * 0.2);\n  3922→\n  3923→            if (p < 1) {\n  3924→                requestAnimationFrame(animate);"
  }
]